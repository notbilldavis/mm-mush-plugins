<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>

<plugin name="cooking_helper" author="Oona" id="853dc761db5b4b38b3e42167"
   purpose="help with cooking, tracking who eats your stuff, etc"
   save_state="y" language="Lua" requires="4.71" version="1.0">

<description trim="y">

<![CDATA[

This plugin helps you track recipes, who eats them, and manage your cooking-related tasks.

Looking at a recipe index card will automatically track the recipe and its ingredients while
giving you helpful links to get ingredients, track ingredients, and more.

Commands:

* cooking - shows current tracked recipes and who has eaten them
* cooking track <consumer name> r:<recipe name> - add a consumer to a recipe
* cooking clear - clear all tracked recipes
* cooking clear <recipe name> - remove a recipe from tracking
* cooking clean - clean up duplicates in all recipes
* cooking clean <recipe name> - clean up duplicates in a recipe
* cooking npcs - shows NPCs that will eat your food
* cooking containers - shows available containers for ingredients
* cooking containers <container> - set the containers to use for getting ingredients (comma-separated)
* cooking search - search your inventory for ingredients of your current recipe
* cooking getall <container> - get all ingredients for your current recipe from a specified container
* cooking find <ingredient> - find a specific ingredient by looking it up in the database
* cooking pouch - toggle pouch tracking which will open a pouch of plenitude, get all from it, and store what you want
* cooking pouch track <ingredient> - track an ingredient in the pouch to keep in your container, drop the rest
* cooking pouch container <container> - set the container you want to put tracked ingredients in (default is trunk)

]]>

</description>

</plugin>

<aliases>
  <alias match="^cooking[ ]+setchar[ ]+(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>SetCharacterName("%1")</send>
  </alias>

  <alias match="^cooking$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>ShowCooking()</send>
  </alias>

  <alias match="^cooking[ ]+track(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>TrackRecipe("%1")</send>
  </alias>

  <alias match="^cooking[ ]+clear(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>ClearRecipe("%1")</send>
  </alias>

  <alias match="^cooking[ ]+clean(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>CleanRecipe("%1")</send>
  </alias>

  <alias match="^cooking[ ]+npcs?(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>ShowNpcs("%1")</send>
  </alias>

  <alias match="^cooking[ ]+config(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>Configure("%1")</send>
  </alias>

  <alias match="^cooking[ ]+search$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>SearchCurrentRecipe()</send>
  </alias>

  <alias match="^cooking[ ]+getall(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>GetAll("%1")</send>
  </alias>

  <alias match="^cooking[ ]+find[ ]+(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>FindIngredient("%1")</send>
  </alias>

  <alias match="^cooking[ ]+pouch$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>Configure("automate")</send>
  </alias>

  <alias match="^cooking[ ]+pouch[ ]+track(.*)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>TrackPouchIngredient("%1")</send>
  </alias>

  <alias match="^cooking[ ]+cook(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>CookRecipe("%1")</send>
  </alias>
</aliases>

<triggers>
  <trigger enabled="y" name="first_prompt" keep_evaluating="y" match="^(|[^ ]+(.*?))(\&lt;(.+)hp (.+)sp (.+)st\&gt;|\(.+\)) $" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>OnFirstPrompt()</send>
  </trigger>

  <trigger enabled="y" name="other_prompt" keep_evaluating="y" match="^(|[^ ]+(.*?))(\&lt;(.+)hp (.+)sp (.+)st\&gt;|\(.+\)) $" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>OnAnyPrompt()</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100" group="cooking_helper" match="^(.*?) hungrily gobbles (.*?) down\.$">
    <send>AddNpcTracking("%1", "%2")</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100" group="cooking_helper" match="^(.*?) is not impressed by your cuisine and discards the meal\. But they are feeling generous today\, and will allow you to try again\.$">
    <send>RemoveLastNpc("%1")</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100" group="cooking_helper" match="^The recipe for (.*?)\:$">
    <send>StartRecipeCapture("%1")</send>
  </trigger>

  <trigger group="get_recipe" keep_evaluating="y" regexp="y" send_to="14" sequence="100" omit_from_output="y" match="^(\s+)\[(.*?)\]$">
    <send>AddIngredientToRecipe("%2", TriggerStyleRuns, "%0")</send>
  </trigger>

  <trigger group="get_recipe" keep_evaluating="y" regexp="y" send_to="12" sequence="100" match="^cooking recipe that you do not already have the mark for\.  $">
    <send>EndRecipeCapture()</send>
  </trigger>

  <trigger group="get_recipe" keep_evaluating="y" regexp="y" send_to="12" sequence="100" match="^You have (.*?) experience for the mark of (.*?)\.$">
    <send>EndRecipeCapture()</send>
  </trigger>

  <trigger group="search_recipe" keep_evaluating="n" regexp="y" send_to="14" omit_from_output="y" sequence="100" match="^(.*?) found in(.*?)$">
    <send>SearchFoundIngredient("%1", "%2")</send>
  </trigger>

  <trigger group="search_recipe" keep_evaluating="n" regexp="y" send_to="14" omit_from_output="y" sequence="100" match="^No matching items found\.$">
    <send>SearchNotFoundIngredient()</send>
  </trigger>

  <trigger group="search_recipe" keep_evaluating="n" regexp="y" send_to="14" omit_from_output="y" sequence="100" match="^\.\.\.and more (.*?)\.$">
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^[ ]+a pouch of plenitude \(new\)$" regexp="y" send_to="14" omit_from_output="y" sequence="100" group="cooking_helper">
    <send>DisplayPouchStatus(TriggerStyleRuns, "%0")</send>
  </trigger>

  <trigger enabled="y" group="cooking_pouch" keep_evaluating="y" match="^Your a pouch of plenitude glows white as it accumulates possessions from the ether\.$" regexp="y" send_to="12" sequence="100">
    <send>LootPouch()</send>
  </trigger>

  <trigger enabled="y" group="cooking_pouch" keep_evaluating="y" match="^You open a pouch of plenitude\.$" regexp="y" send_to="12" sequence="100">
    <send>StartPouchAutomation()</send>
  </trigger>

  <trigger enabled="y" group="cooking_pouch" keep_evaluating="y" match="^You close a pouch of plenitude\.$" regexp="y" send_to="12" sequence="100">
    <send>StopPouchAutomation()</send>
  </trigger>

  <trigger group="cooking_open_pouch" keep_evaluating="y" match="^You take (\d+ of )?(.*?) from a pouch of plenitude\.$" regexp="y" send_to="12" sequence="100">
    <send>HandlePouchIngredient("%2")</send>
  </trigger>

  <trigger group="cooking_open_pouch" keep_evaluating="y" match="^(.*?) emits a bright flare of white light as you take it and it binds with you\.$" regexp="y" send_to="12" sequence="100">
    <send>HandlePouchIngredient("%1")</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^You do not have the required items to cook that\.$" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>EndCooking()</send>
  </trigger>

  <trigger enabled="n" keep_evaluating="y" match="^When you look inside\, you see\:$" group="cleaning_ingredients" regexp="y" omit_from_output="n" send_to="12" sequence="100">
    <send>startCleanCapture()</send>
  </trigger>

  <trigger enabled="n" keep_evaluating="y" match="^A total of (.*?) items weighing (.*?)\.$" group="cleaning_ingredients" regexp="y" omit_from_output="n" send_to="12" sequence="100">
    <send>endCleanCapture()</send>
  </trigger>

  <trigger enabled="n" keep_evaluating="y" match="^(.*?)$" group="cleaning_ingredients" regexp="y" omit_from_output="y" send_to="14" sequence="100">
    <send>cleanCapture("%0")</send>
  </trigger>

  <trigger group="quick_cooking" keep_evaluating="n" regexp="y" send_to="14" omit_from_output="y" sequence="100" match="^(.*?)$">
    <send>CheckIfIngredient("%1")</send>
  </trigger>
</triggers>

<script>

<![CDATA[

function OnPluginInstall() PluginStart() end
function OnPluginEnable() PluginStart() end
function OnPluginConnect() PluginStart() end

function OnPluginBroadcast(msg, id, name, text)
  HandlePluginBroadcast(msg, id, name, text)
end

local missing_required_files = {}
local updater_installed, update_helper = pcall(require, "updatehelper")
local serializer_installed, serialization_helper = pcall(require, "serializationhelper")
local config_installed, config_window = pcall(require, "configuration_miniwindow")

if updater_installed and update_helper.version == nil  then
  update_helper.Update({{ local_file = GetInfo(56):gsub("\\", "/") .. "lua/updatehelper.lua", remote_file = "https://raw.githubusercontent.com/notbilldavis/mm-mush-plugins/refs/heads/main/lua/updatehelper.lua"}})
  package.loaded["updatehelper"] = nil
  can_update, update_helper = pcall(require, "updatehelper")
end

if updater_installed then
  if not serializer_installed then serializer_installed, serialization_helper = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/serializationhelper.lua") end
  if not config_installed then config_installed, config_window = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/configuration_miniwindow.lua") end
  
  local db_file = io.open(GetInfo(66) .. "recipes.db", "r")
  if db_file then io.close(db_file)
  else update_helper.Update(GetInfo(66), "recipes.db")
  end
end

if not serializer_installed then table.insert(missing_required_files, "lua/serializationhelper.lua") end
if not config_installed then table.insert(missing_required_files, "lua/configuration_miniwindow.lua") end

local config = nil
local tracked_recipes = { }
local current_recipe = { }
local search_count = 0
local search_found = { }
local search_containers = {}
local npc_names = {}
local last_npc_food = {}
local character_name = nil
local cooking = false
local cooking_amount = 1
local cooking_infinite = false
local pulled_food = false
local clean_started = false
local clean_captured = {}
local automation_temp_off = false
local triggered_while_off = false
local checking_ingredients = false
local quick_cooking_count = { }

local db = nil

local npcs = { 
  { name = "Faltel", area = "Templeton", room = "Fox Fur Tavern", num = "45972", race = "Elf" },
  { name = "Shady", area = "Templeton", room = "Fool's Gold Tavern", num = "47034", race = "Human" },
  { name = "Grundel", area = "Templeton", room = "Fisherman's Cafe", num = "46452", race = "Human" },
  { name = "Urkfet, the bartender", area = "Tellerium", room = "Seagull Tavern", num = "41835", race = "Troll" },
  { name = "Bovel, the barkeep", area = "Tellerium", room = "Peachtree Tavern", num = "41807", race = "Mino" },
  { name = "Miller the bartender", area = "Winton", room = "The Trash Compactor Bar and Grill", num = "335857", race = "Human" },
  { name = "Flam", area = "Rune", room = "Flam's Steak House", num = "10722", race = "Dracon" },
  { name = "Friedburg", area = "Lowangen", room = "Friedburg's Training", num = "16090", race = "Human" },
  { name = "Finn", area = "A Hill Giant Refuge", room = "Finn's Tavern", num = "345845", race = "Giant" },
  { name = "a rapacious chemwalker", area = "Dungeon Deceit", room = "", num = "", race = "" },
  { name = "Angus", area = "Smuggler's Gulch", room = "The Far End of the Saloon", num = "9373", race = "Human" },
  { name = "Hungry Harmook", area = "Towne of Decara", room = "An Overflowing Workshop", num = "116305", race = "Llamataur" },
  { name = "Shroom", area = "Towne of Decara", room = "The Tipsy Toadstool", num = "116030", race = "Dracon" },
  { name = "a malnourished girl", area = "Refuge of the Xanai", room = "", num = "", race = "" },
  { name = "Alimenta", area = "Rahdiyr", room = "Alimenta's Tavern", num = "199976", race = "Sidhe" },
  { name = "Sam the Barkeep", area = "Human Outpost", room = "The Bar at the Longbranch", num = "50867", race = "Human" },
  { name = "Cortez, the bartender", area = "Cavhfail", room = "Blue Crescent Tavern", num= "199045", race = "Fey" },
  { name = "a busy bartender", area = "Genauras", room = "", num = "", race = "" },
  { name = "the bartender", area = "A Ghost Town", room = "", num = "", race = "" },
  { name = "Grundy the Bartender", area = "Renn", room = "The Juggling Gopher", num = "78967", race = "halfling" },
  { name = "a bartender with a low-cut top", area = "Hlegmal's Tavern", room = "The Back Bar", num = "385957", race = "Orc" },
  { name = "a famished ghast", area = "Domain of Arbaces", room = "", num = "", race = "" },
}

local non_food_items = {
  ["a cold glass of milk"] = true,
  ["some buche syrup"] = true,
  ["a bottle of lager"] = true,
  ["a bottle of pesto"] = true,
  ["a dollop of whipped cream"] = true,
  ["a carton of soup stock"] = true,
  ["a small salt crystal"] = true,
  ["a chilled pastry crust"] = true,
  ["a bag of powdered sugar"] = true,
  ["a sack of brown sugar"] = true,
  ["a vorma seed"] = true,
  ["a wineskin of gomutra ghanvati"] = true,
  ["a bottle of white wine"] = true,
  ["a cup of water"] = true,
  ["a faerie rum blend"] = true,
}

function PluginStart()
  if #missing_required_files > 0 then
    ColourNote("black", "red", GetPluginName() .. ": You are missing the following required file(s): " .. table.concat(missing_required_files, ", "))
    EnableTriggerGroup("cooking_helper", false)
    EnableTriggerGroup("cooking_pouch", false)
    EnableAliasGroup("cooking_helper", false)
    return
  else
    EnableTriggerGroup("cooking_helper", true)
    EnableTriggerGroup("cooking_pouch", true)
    EnableAliasGroup("cooking_helper", true)
  end
  EnableTrigger("first_prompt", true)
  EnableTriggerGroup("cooking_open_pouch", false)
  character_name = nil
  for _, npc in ipairs(npcs) do
    npc_names[npc.name:lower()] = true
  end
end

function HandlePluginBroadcast(msg, id, name, text)
  if #missing_required_files > 0 then return end
  if (id == "f67c4339ed0591a5b010d05b" and text == "char.base") then
    if character_name == nil or character_name == "" then
      local character = serialization_helper.GetGmcpValue(text)
      SetCharacterName(character.name)
    end
  elseif id == "892911b648d09c18e1ecd4e6" and msg == 3 then
    if config.automate_pouch then
      if text:lower() == "off" then 
        Note("Temporarily turning off pouch automation so you don't drop the body part!")
        automation_temp_off = true
      elseif automation_temp_off then
        Note("Turning pouch automation back on!")
        automation_temp_off = false
        if triggered_while_off then LootPouch() end
      end
    end
  end
end

function OnFirstPrompt()
  EnableTrigger("first_prompt", false)
  Execute("sendgmcp char.base")
end

function OnAnyPrompt()
  EnableTriggerGroup("quick_cooking", false)

end

function SetCharacterName(name)
  if name == nil or Trim(name) == "" then
    Note("Unknown character name, set with 'cooking setchar <name>'") 
  else
    character_name = Trim(name)

    tracked_recipes = serialization_helper.GetSerializedVariable(character_name .. "_cooking_recipes")
    config = serialization_helper.GetSerializedVariable(character_name .. "_cooking_config")
    
    config.storage_container = serialization_helper.GetValueOrDefault(config.storage_container, "trunk")
    config.tracked_ingredients = serialization_helper.GetValueOrDefault(config.tracked_ingredients, {})
    config.automate_pouch = serialization_helper.GetValueOrDefault(config.automate_pouch, false)
    config.autoupdate = serialization_helper.GetValueOrDefault(config.autoupdate, true)
    
    DoAfterSpecial(1, "notifyPouchStatus()", sendto.script)
  end
end

function notifyPouchStatus()
  if config.automate_pouch then
    ColourTell("white", "black", "Pouch of Plenty automation is enabled. [")
    Hyperlink("!!" .. GetPluginID() .. ":Configure(\"automate\")", "disable", "Disable Automation", "red", "black", false)
    ColourNote("white", "black", "]")
    EnableTriggerGroup("cooking_pouch", true)
    LootPouch()
  else
    ColourTell("silver", "black", "Pouch of Plenty automation is disabled. [")
    Hyperlink("!!" .. GetPluginID() .. ":Configure(\"automate\")", "enable", "Enable Automation", "green", "black", false)
    ColourNote("silver", "black", "]")
    EnableTriggerGroup("cooking_pouch", false)
  end
end

function ShowCooking()
  local total_tracked = 0
  for _, recipe in pairs(tracked_recipes) do
    if total_tracked == 0 then
      Note("You are currently tracking the following recipes:")
    end
    if recipe.name and recipe.name ~= "" then
      total_tracked = total_tracked + 1
      ColourTell("cyan", "black", " * ")
      ColourTell("white", "black", recipe.name:upper())
      ColourTell("gray", "black", " [")
      Hyperlink("!!" .. GetPluginID() .. ":ShowNpcs(" .. recipe.name .. ")", "n", "Show NPCs that will eat this", "silver", "black", false)
      ColourTell("gray", "black", "]")
      ColourTell("gray", "black", " [")
      Hyperlink("!!" .. GetPluginID() .. ":ClearRecipe(" .. recipe.name .. ")", "X", "Clear", "red", "black", false)
      ColourNote("gray", "black", "]")
      showEaten(recipe.eaten)
    end
  end
  if total_tracked == 0 then
    Note("You are not currently tracking any recipes.")
  end
  Tell("-- type '")
  ColourTell("white", "black", "cooking track ")
  ColourTell("silver", "black", "<recipe name>")
  ColourTell("white", "black", " c:")
  ColourTell("silver", "black", "<consumer name>")
  Note("' to track a new recipe and/or consumer --")

  Tell("-- type '")
  Hyperlink("cooking npcs", "cooking npcs", "", "white", "black", false)
  Note("' to view npcs that will eat your food --")

  if config.automate_pouch then
    Tell("-- type '")
    Hyperlink("cooking pouch track", "cooking pouch track", "", "white", "black", false)
    Note("' to view your tracked ingredients --")
  end
end

function showEaten(eaten)
  local total_eaten = 0
  if type(eaten) == "table" then
    for _, consumer in pairs(eaten) do
      if type(consumer) == "table" then
        if consumer.name and consumer.name ~= "" then
          total_eaten = total_eaten + 1
          local formatted_name = consumer.name:gsub("(%w)(%w*)", function(a,b) return string.upper(a)..b end)
          ColourTell("magenta", "black", "  - ")
          ColourTell("white", "black", formatted_name)
          ColourNote("yellow", "black", " (" .. consumer.date .. ")")
        end
      end
    end
  end
  if total_eaten == 0 then
    ColourTell("magenta", "black", "  - ")
    ColourNote("white", "black", "no one has eaten this yet!")
  end
end

function TrackRecipe(args)
  local recipe_name, consumer = args:match("^(.-)%s+c:(.+)$")
  if not recipe_name then recipe_name = args end

  if recipe_name == nil or Trim(recipe_name) == "" then
    Note("You must specify a recipe name to track.")
    return
  end

  recipe_name = Trim(recipe_name)
  if not tracked_recipes[recipe_name:upper()] then
    local found = false
    for _, recipe in pairs(tracked_recipes) do
      if string.find(recipe.name:upper(), recipe_name:upper()) ~= nil then
        recipe_name = recipe.name
        found = true
        break
      end
    end
    if not found then tracked_recipes[recipe_name:upper()] = { name = recipe_name, eaten = { } } end
  end

  if consumer ~= nil and Trim(consumer) ~= "" then
    consumer = Trim(consumer)
    if tracked_recipes[recipe_name:upper()].eaten[consumer:upper()] then
      Note("Consumer '" .. consumer .. "' has already eaten '" .. recipe_name .. "'")
    else
      tracked_recipes[recipe_name:upper()].eaten[consumer:upper()] = { name = consumer, date = os.date('%Y-%m-%d %H:%M:%S') }
      Note("Consumer '" .. consumer .. "' has been recorded as having eaten '" .. recipe_name .. "'")
    end
  end

  serialization_helper.SaveSerializedVariable(character_name .. "_cooking_recipes", tracked_recipes)
end

function ClearRecipe(args)
  if Trim(args) == "" then
    tracked_recipes = { }
    Note("All tracked recipes have been cleared.")
  else
    local recipe_name = Trim(args)
    if tracked_recipes[recipe_name:upper()] then
      tracked_recipes[recipe_name:upper()] = nil
      Note("Recipe '" .. recipe_name .. "' has been removed from tracking.")
    else
      Note("Recipe '" .. recipe_name .. "' is not being tracked.")
    end
  end

  serialization_helper.SaveSerializedVariable(character_name .. "_cooking recipes", tracked_recipes)
end

function CleanRecipe(args)
  local cleaned = false
  args = Trim(args or ""):upper()
  for _, recipe in ipairs(tracked_recipes) do
    if args == "" or args == "ALL" or string.find(recipe.name:upper(), args) ~= nil then
      local consumers = {}
      for _, consumer in ipairs(recipe.eaten) do
        consumers[consumer.name:upper()] = consumer
      end

      local dupes = #recipe.eaten - #consumers
      if dupes > 0 then
        Note("Cleaned up '" .. recipe.name .. "' removing " .. dupes .. " duplicates.")
        tracked_recipes[recipe.name:upper()].eaten = consumers
        cleaned = true
      end
    end
  end

  if not cleaned then
    Note("No duplicates found for '" .. (args == "" and "all recipes" or args) .. "'")
  else
    serialization_helper.SaveSerializedVariable(character_name .. "_cooking recipes", tracked_recipes)
  end
end

function ShowNpcs(filter)
  if Trim(filter) ~= "" then
    local found = false
    local found_recipe = nil
    for _, recipe in pairs(tracked_recipes) do
      if string.find(recipe.name:upper(), Trim(filter:upper())) ~= nil then
        filter = recipe.name
        found_recipe = recipe
        found = true
        break
      end
    end
    if not found then 
      Note("You aren't tracking a recipe called " .. filter .. "!")
    else
      local feed_count = 0
      for _, npc in ipairs(npcs) do
        if not found_recipe.eaten[npc.name:upper()] then
          if feed_count == 0 then 
            Note("You can still feed " .. filter .. " to the following npcs:")
          end
          feed_count = feed_count + 1
          showNpcDetails(npc.name, npc.area, npc.room, npc.num, npc.race)
        end
      end
    end
  else
    Note("NPCs that will eat your food:")
    for _, npc in ipairs(npcs) do
      showNpcDetails(npc.name, npc.area, npc.room, npc.num, npc.race)
    end
  end
  SendNoEcho("")
end

function showNpcDetails(name, town, room, num, race)
  ColourTell("cyan", "black", " * ")
  ColourTell("white", "black", name)
  ColourTell("yellow", "black", " (" .. town .. ") ")
  if room ~= nil and room ~= "" and num ~= nil and num ~= "" then
    Hyperlink("mapper goto " .. num, "[" .. room .. "]", "", "silver", "black", false)
  end
  if race ~= nil and race ~= "" then
    ColourNote("green", "black", " - " .. race)
  else
    Note("")
  end
end

function Configure(args)
  if not args or Trim(args) == "" then
    local ingredients_text, ingredients_text_display = "", ""
    for ing, tracked in pairs(config.tracked_ingredients) do
      if tracked then
        if ingredients_text ~= "" then ingredients_text = ingredients_text .. ", " end
        ingredients_text = ingredients_text .. ing
      end
    end
    ingredients_text_display = ingredients_text
    if #ingredients_text > 20 then ingredients_text_display = ingredients_text:sub(1, 17) .. "..." end

    local config_options = {
      Options = {
        storage_container = { sort = 1, type = "text", label = "Container", value = config.storage_container, raw_value = config.storage_container },
        tracked_ingredients = { sort = 2, type = "text", label = "Ingredients (comma-separated)", value = ingredients_text_display, raw_value = ingredients_text },
        automate_pouch = { sort = 3, type = "bool", label = "Automate (open, loot, close)", raw_value = true },
        autoupdate = { sort = 4, type = "bool", label = "Auto-Update on Close", raw_value = true },
      }
    }

    config_window.Show(config_options, configureDone)
  else
    local args_split = utils.split(Trim(args), " ", 1)
    local option, value = Trim(args_split[1]:lower()), Trim(args_split[2] or "")
    
    if option == "container" then
      if Trim(value) == "" then 
        value = utils.inputbox("Container", "Enter the name of the container you store your ingredients in:", config.storage_container) 
      end
      if value ~= nil then configureDone("Options", "storage_container", { label = "Container", raw_value = value }) end
    elseif option == "ingredients" then
      if Trim(value) == "" then 
        value = utils.inputbox("Track Ingredients", "Enter a comma-separated list of ingredients to save when automating the pouch of plenitude:", table.concat(config.tracked_ingredients, ", ")) 
      end
      if value ~= nil then configureDone("Options", "tracked_ingredients", { label = "Ingredients", raw_value = value }) end
    elseif option == "automate" then
      if Trim(value) == "" then
        value = not config.automate_pouch
      else
        value = (value:lower() == "true" or value:lower() == "yes" or value:lower() == "on")
      end
      if value ~= nil then configureDone("Options", "automate_pouch", { label = "Automate Pouch", raw_value = value }) end
    elseif option == "autoupdate" then
      if Trim(value) == "" then
        value = not config.autoupdate
      else
        value = (value:lower() == "true" or value:lower() == "yes" or value:lower() == "on")
      end
      if value ~= nil then configureDone("Options", "autoupdate", { label = "Auto-Update on Close", raw_value = value }) end
    else
      Note("Unknown configuration option: " .. option)
      Note("Available options: container, ingredients, automate, autoupdate")
      Note("Use 'cooking config' to see and change all settings.")
    end
  end  
end

function configureDone(group_id, option_id, config_changed)
  if option_id == "tracked_ingredients" then
    config.tracked_ingredients = {}
    for _, ingredient in ipairs(utils.split(Trim(config_changed.raw_value):lower(), ",")) do
      ingredient = Trim(ingredient:lower())
      if ingredient ~= "" then
        config.tracked_ingredients[ingredient] = true
      end
    end
  else
    config[option_id] = config_changed.raw_value
  end

  local changed_value = tostring(config_changed.raw_value)
  if type(config_changed.raw_value) == "boolean" then changed_value = (config_changed.raw_value and "enabled" or "disabled") end
  Note(config_changed.label .. " has been updated to: " .. changed_value)

  if config_changed.label == "Automate Pouch" then
    if config.automate_pouch then
      EnableTriggerGroup("cooking_pouch", true)
      LootPouch()
    else
      EnableTriggerGroup("cooking_pouch", false)
    end
  end

  serialization_helper.SaveSerializedVariable(character_name .. "_cooking_config", config)

  local config_options = {
    Options = {
      storage_container = { sort = 1, type = "text", label = "Container", value = config.storage_container, raw_value = config.storage_container },
      tracked_ingredients = { sort = 2, type = "text", label = "Ingredients (comma-separated)", value = ingredients_text_display, raw_value = ingredients_text },
      automate_pouch = { sort = 3, type = "bool", label = "Automate (open, loot, close)", raw_value = true },
      autoupdate = { sort = 4, type = "bool", label = "Auto-Update on Close", raw_value = true },
    }
  }

  config_window.Update(config_options)
end

function SearchCurrentRecipe()
  if current_recipe == nil or current_recipe.name == nil or #current_recipe.name == 0 or #current_recipe.ingredients == 0 then
    Note("No recipe is currently being tracked. Use 'cooking search' after viewing a recipe card.")
    return
  end

  search_count = 0
  search_found = { }
  if not cooking then
    Note("Searching for ingredients to cook " .. current_recipe.name .. ", please wait...")
  else
    EnableTriggerGroup("quick_cooking", true)
    StartQuickCookingSearch()
  end
end

function GetAll(container)
  if current_recipe == nil or current_recipe.name == nil or #current_recipe.name == 0 or #current_recipe.ingredients == 0 then
    Note("No recipe is currently being tracked. Use 'cooking getall' after viewing a recipe card.")
    return
  end

  if container == nil or container == "" then
    container = Trim(config.storage_container)
  end
  
  Note("Getting all ingredients for " .. current_recipe.name .. " from " .. container .. "...")
  
  local wait_time = .5
  for _, i in ipairs(current_recipe.ingredients) do
    DoAfterSpecial(wait_time, "getIngredient(\"" .. i .. "\", \"" .. container .. "\")", sendto.script)
    wait_time = wait_time + .5
  end
end

function getIngredient(ingredient, container)
  SendNoEcho("get \"" .. ingredient .. "\" " .. container)
end

function doFinalCook()
  if cooking then
    SendNoEcho("cook " .. current_recipe.name)
    SendNoEcho("put '" .. current_recipe.name .. "' " .. Trim(config.storage_container))
  end
end

function FindIngredient(ingredient)
  if ingredient == nil or Trim(ingredient) == "" then
    Note("You must specify an ingredient to search for.")
    return
  end

  if db ~= nil then
    pcall(function() db:close() end)
    db = nil
  end
  db = assert(sqlite3.open(GetInfo(66) .. "recipes.db"))

  Note("Searching DB for '" .. ingredient .. "'")
  local found_ingredients = {}
  for row in db:nrows(string.format("SELECT area, details, notes FROM ingredients WHERE name = '" .. Trim(ingredient) .. "'")) do
    found_ingredients[#found_ingredients + 1] = row
  end

  if #found_ingredients == 0 then
    Note("No results found for '" .. ingredient .. "'.")
  else
    Note("Found " .. #found_ingredients .. " result(s) for '" .. ingredient .. "':")
    for _, row in ipairs(found_ingredients) do
      displayIngredient(row)
    end
  end
end

function displayIngredient(row)
  ColourTell("cyan", "black", " * ")
  if row.area ~= nil and #row.area > 0 then
    ColourTell("white", "black", row.area)
  else
    ColourTell("red", "black", "UNKNOWN")
  end 
    
  ColourTell("silver", "black", " - ")

  if row.details ~= nil and #row.details > 0 then
    ColourTell("white", "black", row.details)
    if row.notes ~= nil and #row.notes > 0 then
      ColourTell("white", "black", "(" .. row.notes .. ")")
    end
  elseif row.notes ~= nil and #row.notes > 0 then
    ColourTell("white", "black", row.notes)
  end

  Note("")
end

function TrackPouchIngredient(ingredient)
  if ingredient and Trim(ingredient) ~= "" then
    ingredient = Trim(ingredient:lower())
    if ingredient == "clear" then
      config.tracked_ingredients = {}      
    elseif ingredient == "clean" then
      cleanContainerOfIngredients()
    else
      config.tracked_ingredients[ingredient] = not config.tracked_ingredients[ingredient]
      if config.tracked_ingredients[ingredient] then
        Note("Tracking " .. ingredient .. " in pouch of plenitude.")
      else
        Note("Stopped tracking " .. ingredient .. " in pouch of plenitude.")
      end
    end
    serialization_helper.SaveSerializedVariable(character_name .. "_cooking_config", config)
  else
    local t_count = 0
    for ing, t in pairs(config.tracked_ingredients) do
        ing = Trim(ing:lower())
        if t_count == 0 then
          Note("Tracked ingredients in pouch of plenitude:")
        end
        if t then
          ColourTell("silver", "black", " * ")
          ColourTell("white", "black", ing)
          ColourTell("gray", "black", " [")
          Hyperlink("!!" .. GetPluginID() .. ":TrackPouchIngredient(" .. ing .. ")", "X", "Clear", "red", "black", false)
          ColourNote("gray", "black", "]")
          
          t_count = t_count + 1
        end
    end
    if t_count == 0 then
      Note("No ingredients are currently being tracked in the pouch of plenitude.")
    else
      Note("A total of " .. t_count .. " ingredients are being tracked.")
    end
    Note("You can toggle tracking of an ingredient with 'cooking pouch track <ingredient>'")
  end
end

function cleanContainerOfIngredients()
  EnableTriggerGroup("cleaning_ingredients", true)
  SendNoEcho("look '" .. config.storage_container .. "'")  
  DoAfterSpecial(2, "endCleanCapture()", sendto.script)
end

function startCleanCapture()
  clean_started = true
  clean_captured = {}
end

function cleanCapture(item)
  if clean_started then
    item = Trim(item:gsub("%s*%b()", ""))
    if item ~= "" then
      clean_captured[item] = (config.tracked_ingredients[item] == true) or tracked_recipes[item:upper()] ~= nil
    end
  end
end

function endCleanCapture()
  EnableTriggerGroup("cleaning_ingredients", false)
  if clean_started then
    clean_started = false
    for item, tracked in pairs(clean_captured) do
      if not tracked then
        SendNoEcho("get all.'" .. item .. "' " .. config.storage_container)
        SendNoEcho("drop all.'" .. item .. "'")
      end
    end
  end  
end

function StartQuickCookingSearch()
  quick_cooking_ingredients = {}
  checking_ingredients = true
  EnableTriggerGroup("quick_cooking", true)
  SendNoEcho("look '" .. config.storage_container .. "'")
  DoAfterSpecial(.2, "EndQuickCookingSearch()", sendto.script)
end

function EndQuickCookingSearch()
  checking_ingredients = false
  EnableTriggerGroup("quick_cooking", false)
  local cooking_total = 0
  for _, i in ipairs(current_recipe.ingredients) do
    local ing = Trim(i:lower())
    if quick_cooking_ingredients[ing] then
      local available = quick_cooking_ingredients[ing]
      if cooking_total == 0 or available < cooking_total then
        cooking_total = available
      end
    else
      cooking_total = -1
      Note("You need " .. ing .. " in order to cook " .. current_recipe.name .. ".")
    end
  end

  if cooking_total > 0 then
    if (cooking_infinite) or (cooking_total < cooking_amount) then
      cooking_amount = cooking_total
      if cooking_infinite then
        cooking_infinite = false
      end
    end

    ColourNote("white", "black", "Cooking " .. current_recipe.name .. " " .. cooking_amount .. " times. (" .. cooking_total .. " possible with your current ingredients)")
    
    local wait_time = .3
    for t = 1, cooking_amount do
      for _, i in ipairs(current_recipe.ingredients) do
        DoAfterSpecial(wait_time, "getIngredient(\"" .. i .. "\", \"" .. config.storage_container .. "\")", sendto.script)
        wait_time = wait_time + .3
      end
      DoAfterSpecial(wait_time, "doFinalCook()", sendto.script)
    end

    DoAfterSpecial(wait_time + .3, "endCook()", sendto.script)
  end
end

function CheckIfIngredient(line)
  if checking_ingredients then
    local cnt, ing, fresh = line:match("^%s*%(?(%d*)%)?%s*([^%(%)]+)%s*%(?([^%)]*)%)?%s*$")
    if not ing then return end
    cnt = tonumber(cnt) or 1
    ing = Trim(ing:lower())
    quick_cooking_ingredients[ing] = cnt
  else
    EnableTriggerGroup("quick_cooking", false)
  end
end

function CookRecipe(times)
  if current_recipe == nil or current_recipe.name == nil or #current_recipe.name == 0 then
    Note("No recipe is currently being tracked. Try again after viewing a recipe card.")
    return
  end

  cooking_amount = tonumber(times) or 1

  if cooking_amount <= 0 then 
    cooking_infinite = true 
  else
    cooking_infinite = false
  end

  cooking = true
  
  SearchCurrentRecipe()
end

function endCook()
  cooking = false
  cooking_amount = 0
  cooking_infinite = false
  Note("Cooking process complete.")
end

--------------
-- triggers --
--------------

function AddNpcTracking(npc, recipe)
  if npc_names[Trim(npc:lower())] then
    TrackRecipe(recipe .. " c:" .. npc)
    last_npc_food = Trim(recipe:lower())
  end
end

function RemoveLastNpc(npc)
  for _, recipe in pairs(tracked_recipes) do
    if string.find(recipe.name:upper(), last_npc_food:upper()) ~= nil then
      local eaten = tracked_recipes[last_npc_food:upper()].eaten
      if eaten[Trim(npc:upper())] then
        eaten[Trim(npc:upper())] = nil
        Note("Consumer '" .. npc .. "' has been removed from the '" .. last_npc_food .. "' list of consumers.")
      end
      break
    end
  end
end

function StartRecipeCapture(recipe_name)
  if recipe_name == nil or recipe_name == "" then
    return
  end

  search_containers = {}
  search_found = {}
  search_count = 0
  current_recipe = { name = recipe_name, ingredients = { } }
  EnableTriggerGroup("get_recipe", true)
end

function AddIngredientToRecipe(ingredient, trigger_style_runs, line)
  local fgcol = "lightgray"
  local bgcol = "black"
  for i = 1, #trigger_style_runs do
    fgcol = RGBColourToName(trigger_style_runs[i].textcolour)
    bgcol = RGBColourToName(trigger_style_runs[i].backcolour)
    ColourTell(fgcol, bgcol, trigger_style_runs[i].text)
  end

  ingredient = Trim(ingredient:lower())
  if config.automate_pouch and not config.tracked_ingredients[ingredient] then
    ColourTell(fgcol, bgcol, " [")
    Hyperlink("!!" .. GetPluginID() .. ":TrackPouchIngredient(" .. ingredient .. ")", "+", "add " .. Trim(ingredient) .. " to tracked ingredients", "lightgreen", "black", false)
    ColourTell(fgcol, bgcol, "]")
  end

  Note("")

  if current_recipe == nil or current_recipe.name == nil or #current_recipe.name == 0 then
    return
  end

  table.insert(current_recipe.ingredients, ingredient)
end

function EndRecipeCapture()
  EnableTriggerGroup("get_recipe", false)
  
  Note("")
  Hyperlink("cooking search", "[Search]", "", "silver", "black", false)
  Tell(" - ")
  if current_recipe.name ~= nil and #current_recipe.name > 0 then
    Hyperlink("!!" .. GetPluginID() .. ":CookRecipe(1)", "[Cook 1]", "Cook " .. Trim(current_recipe.name), "silver", "black", false)
    Tell(" ")
    Hyperlink("!!" .. GetPluginID() .. ":CookRecipe(2)", "[Cook 2]", "Cook " .. Trim(current_recipe.name) .. " twice!", "silver", "black", false)
    Tell(" ")
    Hyperlink("!!" .. GetPluginID() .. ":CookRecipe(0)", "[Cook All]", "Cook " .. Trim(current_recipe.name) .. " as many times as you can!", "silver", "black", false)
    Tell(" - ")
  end
  ColourTell("silver", "black", "Get All:")
  if config.storage_container ~= nil and #config.storage_container > 0 then
    Tell(" ")
    Hyperlink("cooking getall " .. config.storage_container, "[" .. config.storage_container .. "]", "", "silver", "black", false)
  end
  Tell(" - ")
  ColourTell("silver", "black", "Pouch: ")
  Hyperlink("!!" .. GetPluginID() .. ":AddRecipeToPouch()", "[Track All]", "", "silver", "black", false)
  Tell(" - ")
  Hyperlink("!!" .. GetPluginID() .. ":ClearPouch()", "[Clear]", "", "silver", "black", false)
  Note("")
end

function SearchFoundIngredient(ingredient, location)
  if search_found[ingredient] == nil then 
    search_found[ingredient] = 1
    search_count = search_count + 1 
    checkIfDone()
  else
    search_found[ingredient] = search_found[ingredient] + 1
  end

  search_containers[location] = true
end

function SearchNotFoundIngredient()
  search_count = search_count + 1
  checkIfDone()
end

function checkIfDone()
  if search_count == #current_recipe.ingredients then
    DoAfterSpecial(1, "finishSearch()", sendto.script)
  end
end

function finishSearch()
  EnableTriggerGroup("search_recipe", false)

  local not_found = {}
  for _, ingredient in ipairs(current_recipe.ingredients) do
    if not search_found[ingredient] then
      table.insert(not_found, ingredient)
    else
      if search_found[ingredient] < cooking_amount then
        cooking_amount = search_found[ingredient]
      end
    end
  end
  
  if #not_found > 0 then
    if cooking then
      cooking_infinite = false
      cooking = false
      cooking_amount = 0
      Note("Not enough ingredients to cook " .. current_recipe.name .. ".")
    end

    ColourTell("silver", "black", "You need: ")
    for idx, i in ipairs(not_found) do
      Hyperlink("cooking find " .. i, "[" .. i .. "]", "Find", "white", "black", false)
      if idx == #not_found then
        ColourTell("silver", "black", ".")
      else
        ColourTell("silver", "black", ", ")
      end
    end
    Note("")
  else
    if cooking then
      if search_count < 10 and cooking_infinite then
        cooking_infinite = false
      end
      GetAll()
      return
    end

    ColourNote("white", "black", "You have all the ingredients required!")
    Tell("You can find them: ")
    for k, v in pairs(search_containers) do
      ColourTell("cyan", "black", " * ")
      ColourNote("silver", "black", "in" .. k)      
    end

    if current_recipe.name ~= nil and #current_recipe.name > 0 then
      Hyperlink("cook " .. Trim(current_recipe.name), "[Cook]", "", "silver", "black", false)
      Tell(" - ")
    end
    ColourTell("silver", "black", "Get from: ")
  
    Hyperlink("cooking getall " .. config.storage_container, "[" .. config.storage_container .. "]", "", "silver", "black", false)
  end
end

function DisplayPouchStatus(trigger_style_runs, line)
  if not config then return end
  local fgcol = "lightgray"
  local bgcol = "black"
  local status = "disabled"
  if config.automate_pouch then
    status = "enabled"
  end  
  for i = 1, #trigger_style_runs do
    fgcol = RGBColourToName(trigger_style_runs[i].textcolour)
    bgcol = RGBColourToName(trigger_style_runs[i].backcolour)
    local style_text = trigger_style_runs[i].text
    if string.find(style_text, "pouch of plenitude") then
      local pouch_commands = "examine 'a pouch of plenitude'|look in 'a pouch of plenitude'|wear 'a pouch of plenitude'|drop 'a pouch of plenitude'|open 'a pouch of plenitude'|close 'a pouch of plenitude'|eat 'a pouch of plenitude'|drink 'a pouch of plenitude'|empty 'a pouch of plenitude'|light 'a pouch of plenitude'|extinguish 'a pouch of plenitude'|use 'a pouch of plenitude'"
      local pouch_tooltips = "Right mouse click to act on this item|Examine a pouch of plenitude (new)|Look inside a pouch of plenitude (new)|Wear/Hold a pouch of plenitude (new)|Drop a pouch of plenitude (new)|Open a pouch of plenitude (new)|Close a pouch of plenitude (new)|Eat a pouch of plenitude (new)|Drink a pouch of plenitude (new)|Empty a pouch of plenitude (new)|Light a pouch of plenitude (new)|Extinguish a pouch of plenitude (new)|Use a pouch of plenitude (new)"
      Hyperlink(pouch_commands, style_text, pouch_tooltips, fgcol, bgcol, false)
    else
      ColourTell(fgcol, bgcol, trigger_style_runs[i].text)
    end
  end
  ColourTell(fgcol, bgcol, " [")
  ColourTell("white", "black", status)
  ColourNote(fgcol, bgcol, "]")
end

function LootPouch()
  if config.automate_pouch then
    if automation_temp_off then
      triggered_while_off = true
    else
      SendNoEcho("open plenitude")
      SendNoEcho("get all plenitude")
      SendNoEcho("close plenitude")
    end
  end
end

function HandlePouchIngredient(ingredient)
  if not config.automate_pouch or not ingredient or ingredient == "" then
    return
  end

  ingredient = Trim(ingredient:lower())
  
  if config.tracked_ingredients[ingredient] then
    SendNoEcho("put all.\"" .. ingredient .. "\" " .. config.storage_container)
  elseif non_food_items[ingredient] then
    SendNoEcho("drop all.\"" .. ingredient .. "\"")
  else
    pulled_food = true
  end  
end

function AddRecipeToPouch()
  if current_recipe.ingredients == nil or #current_recipe.ingredients == 0 then
    Note("You have no recipe to add to the pouch.")
    return
  end

  for _, ingredient in ipairs(current_recipe.ingredients) do
    ingredient = Trim(ingredient:lower())
    if not config.tracked_ingredients[ingredient] then
      config.tracked_ingredients[ingredient] = true
      ColourNote("green", "black", "Added " .. ingredient .. " to pouch tracking.")
    else
      ColourNote("yellow", "black", ingredient .. " is already being tracked in the pouch.")
    end
  end

  serialization_helper.SaveSerializedVariable(character_name .. "_cooking_config", config)
end

function ClearPouch()
  if #config.tracked_ingredients == 0 then
    Note("You have no tracked ingredients to clear.")
    return
  end

  config.tracked_ingredients = {}
  serialization_helper.SaveSerializedVariable(character_name .. "_cooking_config", config)
  Note("Cleared all ingredients from pouch tracking.")
end

function EndCooking()
  if cooking then
    cooking = false
    Note("An ingredient you need to cook " .. current_recipe.name .. " was not found in " .. config.storage_container .. ".")
  end
end

function StartPouchAutomation()
  EnableTriggerGroup("cooking_open_pouch", true)
end

function StopPouchAutomation()
  EnableTriggerGroup("cooking_open_pouch", false)
  if pulled_food then
    SendNoEcho("drop all.food")
    pulled_food = false
  end
end

]]>

</script>

</muclient>