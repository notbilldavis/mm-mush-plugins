<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>

<plugin name="cooking_helper" author="Oona" id="853dc761db5b4b38b3e42167"
   purpose="help with cooking, tracking who eats your stuff, etc"
   save_state="y" language="Lua" requires="4.71" version="1.0">

<description trim="y">

<![CDATA[

This plugin helps you track recipes, who eats them, and manage your cooking-related tasks.

Looking at a recipe index card will automatically track the recipe and its ingredients while
giving you helpful links to get ingredients, track ingredients, and more.

Commands:

* cooking - shows current tracked recipes and who has eaten them
* cooking track <consumer name> r:<recipe name> - add a consumer to a recipe
* cooking clear - clear all tracked recipes
* cooking clear <recipe name> - remove a recipe from tracking
* cooking clean - clean up duplicates in all recipes
* cooking clean <recipe name> - clean up duplicates in a recipe
* cooking npcs - shows NPCs that will eat your food
* cooking containers - shows available containers for ingredients
* cooking containers <container> - set the containers to use for getting ingredients (comma-separated)
* cooking search - search your inventory for ingredients of your current recipe
* cooking getall <container> - get all ingredients for your current recipe from a specified container
* cooking find <ingredient> - find a specific ingredient by looking it up in the database
* cooking pouch - toggle pouch tracking which will open a pouch of plenitude, get all from it, and store what you want
* cooking pouch track <ingredient> - track an ingredient in the pouch to keep in your container, drop the rest
* cooking pouch container <container> - set the container you want to put tracked ingredients in (default is trunk)

]]>

</description>

</plugin>

<aliases>
  <alias match="^cooking[ ]+setchar[ ]+(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>SetCharacterName("%1")</send>
  </alias>

  <alias match="^cooking$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>ShowCooking()</send>
  </alias>

  <alias match="^cooking[ ]+track(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>TrackRecipe("%1")</send>
  </alias>

  <alias match="^cooking[ ]+clear(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>ClearRecipe("%1", true)</send>
  </alias>

  <alias match="^cooking[ ]+clean(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>CleanRecipe("%1")</send>
  </alias>

  <alias match="^cooking[ ]+npcs?(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>ShowNpcs("%1")</send>
  </alias>

  <alias match="^cooking[ ]+config(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>Configure("%1")</send>
  </alias>

  <alias match="^cooking[ ]+search$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>SearchCurrentRecipe()</send>
  </alias>

  <alias match="^cooking[ ]+getall(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>GetAll("%1")</send>
  </alias>

  <alias match="^cooking[ ]+find[ ]+(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>FindIngredient("%1")</send>
  </alias>

  <alias match="^cooking[ ]+pouch$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>Configure("automate")</send>
  </alias>

  <alias match="^cooking[ ]+pouch[ ]+track(.*)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>TrackPouchIngredient("%1")</send>
  </alias>

  <alias match="^cooking[ ]+cook(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>CookRecipe("%1")</send>
  </alias>

  <alias match="^cooking[ ]+recipe$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>ShowRecipe()</send>
  </alias>

  <alias match="^cooking[ ]+update$" enabled="y" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>UpdatePlugin()</send>
  </alias>
</aliases>

<triggers>
  <trigger enabled="y" name="first_prompt" keep_evaluating="y" match="^(|[^ ]+(.*?))(\&lt;(.+)hp (.+)sp (.+)st\&gt;|\(.+\)) $" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>OnFirstPrompt()</send>
  </trigger>

  <trigger enabled="y" name="other_prompt" keep_evaluating="y" match="^(|[^ ]+(.*?))(\&lt;(.+)hp (.+)sp (.+)st\&gt;|\(.+\)) $" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>OnAnyPrompt()</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100" group="cooking_helper" match="^(.*?) hungrily gobbles (.*?) down\.$">
    <send>AddNpcTracking("%1", "%2")</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100" group="cooking_helper" match="^(.*?) is not impressed by your cuisine and discards the meal\. But they are feeling generous today\, and will allow you to try again\.$">
    <send>RemoveLastNpc("%1")</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100" group="cooking_helper" match="^The recipe for (.*?)\:$">
    <send>StartRecipeCapture("%1")</send>
  </trigger>

  <trigger group="get_recipe" keep_evaluating="y" regexp="y" send_to="14" sequence="100" omit_from_output="y" match="^(\s+)\[(.*?)\]$">
    <send>AddIngredientToRecipe("%2", TriggerStyleRuns, "%0")</send>
  </trigger>

  <trigger group="get_recipe" keep_evaluating="y" regexp="y" send_to="12" sequence="100" match="^cooking recipe that you do not already have the mark for\.  $">
    <send>EndRecipeCapture()</send>
  </trigger>

  <trigger group="get_recipe" keep_evaluating="y" regexp="y" send_to="12" sequence="100" match="^You have (.*?) experience for the mark of (.*?)\.$">
    <send>EndRecipeCapture()</send>
  </trigger>

  <trigger group="get_recipe" keep_evaluating="y" regexp="y" send_to="12" sequence="100" multi_line="y" lines_to_match="2" match="\+\+\+ a recipe book will\, when USEd \<culinary mark you possess\>\, display the\nrecipe associated with that mark(.*?)\Z">
    <send>EndRecipeCapture()</send>
  </trigger>

  <trigger group="search_recipe" keep_evaluating="n" regexp="y" send_to="14" omit_from_output="y" sequence="100" match="^(.*?) found in(.*?)$">
    <send>SearchFoundIngredient("%1", "%2")</send>
  </trigger>

  <trigger group="search_recipe" keep_evaluating="n" regexp="y" send_to="14" omit_from_output="y" sequence="100" match="^No matching items found\.$">
    <send>SearchNotFoundIngredient()</send>
  </trigger>

  <trigger group="search_recipe" keep_evaluating="n" regexp="y" send_to="14" omit_from_output="y" sequence="100" match="^\.\.\.and more (.*?)\.$">
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^[ ]+a pouch of plenitude \(new\)$" regexp="y" send_to="14" omit_from_output="y" sequence="100" group="cooking_helper">
    <send>DisplayPouchStatus(TriggerStyleRuns, "%0")</send>
  </trigger>

  <trigger enabled="y" group="cooking_pouch" keep_evaluating="y" match="^Your (.*?) glows white as it accumulates possessions from the ether\.$" regexp="y" send_to="12" sequence="100">
    <send>LootPouch("%1")</send>
  </trigger>

  <trigger enabled="y" group="cooking_pouch" keep_evaluating="y" match="^You open (.*?)\.$" regexp="y" send_to="12" sequence="100">
    <send>StartPouchAutomation("%1")</send>
  </trigger>

  <trigger enabled="y" group="cooking_pouch" keep_evaluating="y" match="^You close (.*?)\.$" regexp="y" send_to="12" sequence="100">
    <send>StopPouchAutomation("%1")</send>
  </trigger>

  <trigger group="cooking_open_pouch" keep_evaluating="y" match="^You take (\d+ of )?(.*?) from (.*?)\.$" regexp="y" send_to="12" sequence="100">
    <send>HandlePouchIngredient("%2")</send>
  </trigger>

  <trigger group="cooking_open_pouch" keep_evaluating="y" match="^(.*?) emits a bright flare of white light as you take it and it binds with you\.$" regexp="y" send_to="12" sequence="100">
    <send>HandlePouchIngredient("%1")</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^You do not have the required items to cook that\.$" regexp="y" send_to="12" sequence="100" group="cooking_helper">
    <send>EndCooking()</send>
  </trigger>

  <trigger enabled="n" keep_evaluating="y" match="^When you look inside\, you see\:$" group="cleaning_ingredients" regexp="y" omit_from_output="n" send_to="12" sequence="100">
    <send>startCleanCapture()</send>
  </trigger>

  <trigger enabled="n" keep_evaluating="y" match="^A total of (.*?) items weighing (.*?)\.$" group="cleaning_ingredients" regexp="y" omit_from_output="n" send_to="12" sequence="100">
    <send>endCleanCapture()</send>
  </trigger>

  <trigger enabled="n" keep_evaluating="y" match="^(.*?)$" group="cleaning_ingredients" regexp="y" omit_from_output="y" send_to="14" sequence="100">
    <send>cleanCapture("%0")</send>
  </trigger>

  <trigger enabled="n" group="quick_cooking" keep_evaluating="n" regexp="y" send_to="14" omit_from_output="y" sequence="100" match="^(.*?)$">
    <send>CheckIfIngredient("%1")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Trainer\] Friedburg is showing his sneaky ways to future thieves here\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Friedburg")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] Flam the dracon bartender is here\, sharpening his claws\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Flam")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] Finn the bartender leans against the bar awaiting your order\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Finn")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] A one\-horned minotaur tends the bar with a smile\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Bovel, the barkeep")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] A wild\-eyed troll dodges fists while tending to his rowdy clientele\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Urkfet, the bartender")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] Wiping the already clean bar\, Faltel chats with his customers\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Faltel")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] Shady stands behind the bar looking around with trepidation\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Shady")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] Grundel stands here telling stories and serving drinks\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Grundel")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] The bartender\, Miller\, leans gently on the counter\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Miller the bartender")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] A fat\, jovial bartender stands behind the bar\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Grundy the Bartender")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop] Alimenta\, the bar owner\, waits to take your drink order\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Alimenta")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] A man in a white shirt and suspenders stands behind the bar\, serving drinks\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Sam the Barkeep")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] Cortez\, the sagacious faerie bartender hands out drinks\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("Cortez, the bartender")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] A busy bartender stands behind the bar\, longing for a break\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("a busy bartender")</send>
  </trigger>

  <trigger group="cooking_helper" keep_evaluating="y" match="^(.*?)\[Shop\] An orc with a shaved head jiggles seductively as she maintains the bar\.$" regexp="y" send_to="12" sequence="100">
    <send>CheckNpcProgress("a bartender with a low-cut top")</send>
  </trigger>
  
</triggers>

<script>

<![CDATA[

function OnPluginInstall() PluginStart() end
function OnPluginEnable() PluginStart() end
function OnPluginConnect() PluginStart() end
function OnPluginClose() pluginStop() end
function OnPluginDisable() pluginStop() end
function OnPluginDisconnect() pluginStop() end

function OnPluginBroadcast(msg, id, name, text)
  HandlePluginBroadcast(msg, id, name, text)
end

local missing_required_files = {}
local updater_installed, update_helper = pcall(require, "updatehelper")
local serializer_installed, serialization_helper = pcall(require, "serializationhelper")
local config_installed, config_window = pcall(require, "configuration_miniwindow")

if updater_installed and update_helper.version == nil  then
  update_helper.Update({{ local_file = GetInfo(56):gsub("\\", "/") .. "lua/updatehelper.lua", remote_file = "https://raw.githubusercontent.com/notbilldavis/mm-mush-plugins/refs/heads/main/lua/updatehelper.lua"}})
  package.loaded["updatehelper"] = nil
  can_update, update_helper = pcall(require, "updatehelper")
end

if updater_installed then
  if not serializer_installed then serializer_installed, serialization_helper = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/serializationhelper.lua") end
  if not config_installed then config_installed, config_window = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/configuration_miniwindow.lua") end
  
  local db_file = io.open(GetInfo(66) .. "recipes.db", "r")
  if db_file then io.close(db_file)
  else update_helper.Update(GetInfo(66), "recipes.db")
  end
end

if not serializer_installed then table.insert(missing_required_files, "lua/serializationhelper.lua") end
if not config_installed then table.insert(missing_required_files, "lua/configuration_miniwindow.lua") end

local config = nil
local tracked_recipes = { }
local current_recipe = { }
local search_count = 0
local search_found = { }
local search_containers = {}
local npc_names = {}
local last_npc_food = {}
local character_name = nil
local cooking = false
local cooking_amount = 1
local cooking_infinite = false
local pulled_food = false
local clean_started = false
local clean_captured = {}
local automation_temp_off = false
local triggered_while_off = false
local checking_ingredients = false
local quick_cooking_count = { }

local db = nil

local npcs = { 
  { name = "Faltel", area = "Templeton", room = "Fox Fur Tavern", num = "45972", race = "Elf" },
  { name = "Shady", area = "Templeton", room = "Fool's Gold Tavern", num = "47034", race = "Human" },
  { name = "Grundel", area = "Templeton", room = "Fisherman's Cafe", num = "46452", race = "Human" },
  { name = "Urkfet, the bartender", area = "Tellerium", room = "Seagull Tavern", num = "41835", race = "Troll" },
  { name = "Bovel, the barkeep", area = "Tellerium", room = "Peachtree Tavern", num = "41807", race = "Mino" },
  { name = "Miller the bartender", area = "Winton", room = "The Trash Compactor Bar and Grill", num = "335857", race = "Human" },
  { name = "Flam", area = "Rune", room = "Flam's Steak House", num = "10722", race = "Dracon" },
  { name = "Friedburg", area = "Lowangen", room = "Friedburg's Training", num = "16090", race = "Human" },
  { name = "Finn", area = "A Hill Giant Refuge", room = "Finn's Tavern", num = "345845", race = "Giant" },
  { name = "a rapacious chemwalker", area = "Dungeon Deceit", room = "", num = "", race = "" },
  { name = "Angus", area = "Smuggler's Gulch", room = "The Far End of the Saloon", num = "9373", race = "Human" },
  { name = "Hungry Harmook", area = "Towne of Decara", room = "An Overflowing Workshop", num = "116305", race = "Llamataur" },
  { name = "Shroom", area = "Towne of Decara", room = "The Tipsy Toadstool", num = "116030", race = "Dracon" },
  { name = "a malnourished girl", area = "Refuge of the Xanai", room = "", num = "", race = "" },
  { name = "Alimenta", area = "Rahdiyr", room = "Alimenta's Tavern", num = "199976", race = "Sidhe" },
  { name = "Sam the Barkeep", area = "Human Outpost", room = "The Bar at the Longbranch", num = "50867", race = "Human" },
  { name = "Cortez, the bartender", area = "Cavhfail", room = "Blue Crescent Tavern", num= "199045", race = "Fey" },
  { name = "a busy bartender", area = "Genauras", room = "", num = "", race = "" },
  { name = "the bartender", area = "A Ghost Town", room = "", num = "", race = "" },
  { name = "Grundy the Bartender", area = "Renn", room = "The Juggling Gopher", num = "78967", race = "halfling" },
  { name = "a bartender with a low-cut top", area = "Hlegmal's Tavern", room = "The Back Bar", num = "385957", race = "Orc" },
  { name = "a famished ghast", area = "Domain of Arbaces", room = "", num = "", race = "" },
}

local non_food_items = {
  ["a cold glass of milk"] = true,
  ["some buche syrup"] = true,
  ["a bottle of lager"] = true,
  ["a bottle of pesto"] = true,
  ["a dollop of whipped cream"] = true,
  ["a carton of soup stock"] = true,
  ["a small salt crystal"] = true,
  ["a chilled pastry crust"] = true,
  ["a bag of powdered sugar"] = true,
  ["a sack of brown sugar"] = true,
  ["a vorma seed"] = true,
  ["a wineskin of gomutra ghanvati"] = true,
  ["a bottle of white wine"] = true,
  ["a cup of water"] = true,
  ["a faerie rum blend"] = true,
}

local requires_oven = {
  ["a pan of brownies"] = true,
  ["a bagel"] = true,
  ["bagel chips"] = true,
  ["a yule buche"] = true,
  ["a carrot cake"] = true,
  ["a cheese souffle"] = true,
  ["an entire chocolate cake"] = true,
  ["Heirloom Gingerbread"] = true,
  ["oatmeal chocolate chip cookies"] = true,
  ["Bernadette's peanut butter cookies"] = true,
  ["a savory crimini pastry"] = true,
  ["a strawberry shortcake"] = true,
}

local requires_griddle = {
  ["an everything breakfast bagel"] = true,
  ["a breakfast omelette"] = true,
  ["a breakfast taco"] = true,
  ["some buche syrup"] = true,
  ["a chile relleno burrito"] = true,
  ["a bag of corn tortillas"] = true,
  ["a plate of huevos rancheros"] = true,
  ["a light breakfast"] = true,
  ["a tub of mirepoix"] = true,
  ["raised waffles"] = true,
  ["a stack of sourdough pancakes"] = true,
  ["steak and potatoes"] = true,
  ["some soft toffee crunch"] = true,
  ["a crunchy tostada"] = true,
}

local requires_mixing_bowl = {
  ["garden delight salad"] = true,
  ["spaghetti and pesto"] = true,
  ["a dollop of sour cream"] = true,
  ["yeast starter"] = true,
  ["a jar of enchilada sauce"] = true,
  ["a jar of hot fudge sauce"] = true,
  ["a ramekin of pico de gallo"] = true,
  ["an arranged cheese plate"] = true,
  ["a ramekin of salsa roja"] = true,
  ["olive tapenade"] = true,
  ["a dollop of whipped cream"] = true,
  ["some yogurt"] = true,
}

local requires_cauldron = {
  ["a pot of savo beans borracho"] = true,
  ["some buche cream"] = true,
  ["a chile relleno"] = true,
  ["scorpion soup"] = true,
  ["a pot of winterroot soup"] = true,
}

local requires_icebox = {
  ["a brick of cream cheese"] = true,
  ["a piping tube of cream cheese frosting"] = true,
  ["a bag of theater popcorn"] = true,
}

function PluginStart()
  if #missing_required_files > 0 then
    ColourNote("black", "red", GetPluginName() .. ": You are missing the following required file(s): " .. table.concat(missing_required_files, ", "))
    EnableTriggerGroup("cooking_helper", false)
    EnableTriggerGroup("cooking_pouch", false)
    EnableAliasGroup("cooking_helper", false)
    return
  else
    EnableTriggerGroup("cooking_helper", true)
    EnableTriggerGroup("cooking_pouch", true)
    EnableAliasGroup("cooking_helper", true)
  end
  EnableTrigger("first_prompt", true)
  EnableTriggerGroup("cooking_open_pouch", false)
  EnableTriggerGroup("quick_cooking", false)
  character_name = nil
  for _, npc in ipairs(npcs) do
    npc_names[npc.name:lower()] = true
  end
end

function pluginStop()
  if #missing_required_files > 0 then return end
  if can_update and config.autoupdate then
    UpdatePlugin()
  else
    Note("Auto-update for '" .. GetPluginName() .. "' is disabled. Enable it in the plugin configuration to receive updates.")
  end  
end

function HandlePluginBroadcast(msg, id, name, text)
  if #missing_required_files > 0 then return end
  if (id == "f67c4339ed0591a5b010d05b" and text == "char.base") then
    if character_name == nil or character_name == "" then
      local character = serialization_helper.GetGmcpValue(text)
      SetCharacterName(character.name)
    end
  elseif id == "892911b648d09c18e1ecd4e6" and msg == 3 then
    if config.automate_pouch then
      if text:lower() == "off" then 
        Note("Temporarily turning off pouch automation so you don't drop the body part!")
        automation_temp_off = true
      elseif automation_temp_off then
        Note("Turning pouch automation back on!")
        automation_temp_off = false
        if triggered_while_off then LootPouch() end
      end
    end
  end
end

function OnFirstPrompt()
  EnableTrigger("first_prompt", false)
  Execute("sendgmcp char.base")
end

function OnAnyPrompt()
  EnableTriggerGroup("quick_cooking", false)

end

function SetCharacterName(name)
  if name == nil or Trim(name) == "" then
    Note("Unknown character name, set with 'cooking setchar <name>'") 
  else
    character_name = Trim(name)

    tracked_recipes = serialization_helper.GetSerializedVariable(character_name .. "_cooking_recipes")
    config = serialization_helper.GetSerializedVariable(character_name .. "_cooking_config")
    
    config.storage_container = serialization_helper.GetValueOrDefault(config.storage_container, "trunk")
    config.tracked_ingredients = serialization_helper.GetValueOrDefault(config.tracked_ingredients, {})
    config.automate_pouch = serialization_helper.GetValueOrDefault(config.automate_pouch, false)
    config.autoupdate = serialization_helper.GetValueOrDefault(config.autoupdate, true)
    config.enableonstart = serialization_helper.GetValueOrDefault(config.enableonstart, true)
    config.pouchname = serialization_helper.GetValueOrDefault(config.pouchname, "a pouch of plenitude")
    config.logging = serialization_helper.GetValueOrDefault(config.logging, false)
    config.show_grid = serialization_helper.GetValueOrDefault(config.show_grid, true)

    if config.enableonstart then
      config.automate_pouch = true
    end
    
    DoAfterSpecial(1, "notifyPouchStatus()", sendto.script)
  end
end

function notifyPouchStatus()
  if config.automate_pouch then
    ColourTell("white", "black", "Pouch of Plenty automation is enabled. [")
    Hyperlink("!!" .. GetPluginID() .. ":Configure(\"automate\")", "disable", "Disable Automation", "red", "black", false)
    ColourNote("white", "black", "]")
    EnableTriggerGroup("cooking_pouch", true)
    LootPouch()
  else
    ColourTell("silver", "black", "Pouch of Plenty automation is disabled. [")
    Hyperlink("!!" .. GetPluginID() .. ":Configure(\"automate\")", "enable", "Enable Automation", "green", "black", false)
    ColourNote("silver", "black", "]")
    EnableTriggerGroup("cooking_pouch", false)
  end
end

function ShowCooking()
  if config.show_grid then
    showCookingAsGrid()
  else
    showCookingAsList()
  end
end

function showCookingAsGrid()
  local longest_name = getLongestName()
  local total_recipes = 0
  if longest_name <= 0 then
    longest_name = 12
    Note("." .. string.rep("-", 36) .. ".")
    Tell("| ")
    ColourNote("magenta", "black", "There are no recipes being tracked")
    Note(" |")
    Note("." .. string.rep("-", 36) .. ".")
  else
    Note("." .. string.rep("-", longest_name + 24) .. ".")
    for _, recipe in pairs(tracked_recipes) do
      if recipe and recipe.name and #recipe.name > 0 then
        total_recipes = total_recipes + 1
        showRecipeAsGrid(recipe.name, longest_name)
        showEatenAsGrid(recipe.eaten, longest_name)
      end
    end
  end

  local line_options = { "Add Recipe" }
  local options = { "Add Consumer", "All NPCs", "Tracked Ingredients" }
  for i, opt in ipairs(options) do
    local new_line_content = table.concat(line_options, " ") .. " " .. opt
    if #new_line_content < longest_name + 24 then
      table.insert(line_options, opt)
    else
      showOptions(line_options, longest_name + 24)
      line_options = {}
      table.insert(line_options, opt)
    end
  end

  if line_options and #line_options > 0 then
    showOptions(line_options, longest_name + 24)
  end

  Note("." .. string.rep("-", longest_name + 24) .. ".")
  SendNoEcho("")
end

function showRecipeAsGrid(recipe_name, longest_name)
  Tell("| " .. recipe_name:upper() .. string.rep(" ", longest_name - #recipe_name) .. " |  ")
  Hyperlink("!!" .. GetPluginID() .. ":ShowNpcs(" .. recipe_name .. ")", "npcs", "Show NPCs that will eat this", "green", "black", false)
  Tell(" ")
  Hyperlink("!!" .. GetPluginID() .. ":DoClearRecipe(" .. recipe_name .. ")", "clear", "Clear", "orange", "black", false)
  Tell(" ")
  Hyperlink("!!" .. GetPluginID() .. ":DoRemoveRecipe(" .. recipe_name .. ")", "delete", "Delete", "red", "black", false)
  Note("  |")
  Tell("." .. string.rep("-", longest_name + 2) .. ".")
  Note(string.rep("-", 21) .. ".")
end

function showEatenAsGrid(eaten, longest_name)
  local total_eaten = 0
  if eaten and type(eaten) == "table" then
    table.sort(eaten, function(a, b) return b.date < a.date end)
    for _, consumer in pairs(eaten) do
      if consumer and consumer.name and consumer.name ~= "" then
        total_eaten = total_eaten + 1
        local formatted_name = consumer.name:gsub("(%w)(%w*)", function(a,b) return string.upper(a)..b end)
        Tell("| ")
        ColourTell("white", "black", formatted_name .. string.rep(" ", longest_name - #formatted_name + 1))
        Tell("| ")
        ColourTell("yellow", "black", consumer.date .. " ")
        Note("|")
      end
    end
  end
  if total_eaten == 0 then
    Tell("| ")
    ColourTell("magenta", "black", "No one has eaten this yet." .. string.rep(" ", longest_name - 3))
    Note("|")
    Note("." .. string.rep("-", longest_name + 2) .. "." .. string.rep("-", 21) .. ".")
  else
    Note("." .. string.rep("-", longest_name + 24) .. ".")
  end
end

function getLongestName()
  local longest_name = 0
  for _, recipe in pairs(tracked_recipes) do
    if recipe.name and #recipe.name > longest_name then
      longest_name = #recipe.name
    end
    if recipe.eaten then
      for _, consumer in pairs(recipe.eaten) do
        if consumer.name and #consumer.name > longest_name then
          longest_name = #consumer.name
        end
      end
    end
  end
  return longest_name
end

function showOptions(options, total_length)
  local line = table.concat(options, " ")
  if total_length <= #line then
    line = line:sub(1, total_length)
  end

  local padding = total_length - #line
  local left_padding = math.floor(padding / 2)
  local right_padding = padding - left_padding

  Tell("|" .. string.rep(" ", left_padding))
  for _, opt in ipairs(options) do
    if opt == "Add Recipe" then
      Hyperlink("!!" .. GetPluginID() .. ":ClickAddRecipe()", opt, "", "white", "black", false)
    elseif opt == "Add Consumer" then
      Hyperlink("!!" .. GetPluginID() .. ":ClickAddConsumer()", opt, "", "white", "black", false)
    elseif opt == "All NPCs" then
      Hyperlink("!!" .. GetPluginID() .. ":ClickShowNpcs()", opt, "", "white", "black", false)
    elseif opt == "Tracked Ingredients" then
      Hyperlink("!!" .. GetPluginID() .. ":ClickTrackedIngredients()", opt, "", "white", "black", false)
    end
    Tell(" ")
  end
  Note(string.rep(" ", right_padding - 1) .. "|")
end

function ClickAddRecipe()
  local recipe_name = utils.inputbox("What is the name of the final food product of the new recipe?", "Add new recipe", "")
  if recipe_name ~= nil and #recipe_name > 0 then
    addRecipe(recipe_name)
  end
end

function addRecipe(recipe_name)
  recipe_name = Trim(recipe_name)
  if not tracked_recipes[recipe_name:upper()] then
    local found = false
    for _, recipe in pairs(tracked_recipes) do
      if string.find(recipe.name:upper(), recipe_name:upper()) ~= nil then
        recipe_name = recipe.name
        found = true
        break
      end
    end
    if not found then tracked_recipes[recipe_name:upper()] = { name = recipe_name, eaten = { } } end
    ColourNote("cyan", "black", "Now tracking: " .. recipe_name)
  else
    Tell("This recipe is already being tracked. Add a consumer with: ")
    ColourTell("white", "black", "cooking track ")
    ColourTell("cyan", "black", recipe_name)
    ColourTell("white", "black", " c:")
    ColourNote("cyan", "black", "<consumer name>")
  end

  serialization_helper.SaveSerializedVariable(character_name .. "_cooking_recipes", tracked_recipes)
end

function ClickAddConsumer()
  if tracked_recipes == nil then tracked_recipes = {} end
  local choices = {}
  for _, recipe in pairs(tracked_recipes) do
    table.insert(choices, recipe.name)
  end
  if #choices > 0 then
    local recipe_choice = 1
    if #choices > 1 then
      recipe_choice = utils.choose("Which tracked recipe are you adding to?", "Add a consumer", choices)
      if recipe_choice ~= nil then
        addConsumerToRecipe(choices[recipe_choice])
      end
    end
  else
    ColourNote("cyan", "black", "You aren't tracking any recipes to add a consumer to yet.")
  end
end

function addConsumerToRecipe(recipe_name)
  local consumer_name = utils.inputbox("What is the name of the person who ate this recipe?", "Add new consumer", "")
  recipe_name = Trim(recipe_name)
  if consumer_name ~= nil and Trim(consumer_name) ~= "" then
    consumer_name = Trim(consumer_name)
    if tracked_recipes[recipe_name:upper()].eaten[consumer_name:upper()] then
      Note("Consumer '" .. consumer_name .. "' has already eaten '" .. recipe_name .. "'")
    else
      tracked_recipes[recipe_name:upper()].eaten[consumer:upper()] = { name = consumer, date = os.date('%Y-%m-%d %H:%M:%S') }
      Note("Consumer '" .. consumer_name .. "' has been recorded as having eaten '" .. recipe_name .. "'")
    end
  end

  serialization_helper.SaveSerializedVariable(character_name .. "_cooking_recipes", tracked_recipes)
end

function ClickShowNpcs()
  showSpecificNpcs(npcs)
end

function showSpecificNpcs(filtered_npcs)
  local name_len, area_len, room_len, num_len, race_len = 32, 21, 35, 8, 11
  local total_len = name_len + area_len + room_len + num_len + race_len + 4
  Note("." .. string.rep("-", total_len) .. ".")
  Note("| NPC Name" .. string.rep(" ", name_len - 9) .. "| Area" .. string.rep(" ", area_len - 5) .. "| Room" .. string.rep(" ", room_len - 5) .. "| GMCP" .. string.rep(" ", num_len - 5) .. "| Race" .. string.rep(" ", race_len - 5) .. "|")
  Note("|" .. string.rep("-", name_len) .. "." .. string.rep("-", area_len) .. "." .. string.rep("-", room_len) .. "." .. string.rep("-", num_len) .. "." .. string.rep("-", race_len) .. "|")
  for _, npc in ipairs(filtered_npcs) do
    Tell("| ")
    local formatted_name = npc.name:gsub("(%w)(%w*)", function(a,b) return string.upper(a)..b end)    
    ColourTell("white", "black", formatted_name .. string.rep(" ", name_len - #formatted_name - 1))
    Tell("| ")
    ColourTell("yellow", "black", npc.area .. string.rep(" ", area_len - #npc.area - 1))
    Tell("| ")
    if npc.room ~= nil and npc.room ~= "" then
      if npc.num ~= nil and npc.num ~= "" then
        Hyperlink("mapper goto " .. npc.num, npc.room, "", "silver", "black", false)
      else
        ColourTell("silver", "black", npc.room)
      end
      Tell(string.rep(" ", room_len - #npc.room - 1))
    else
      Tell(string.rep(" ", room_len - 1))
    end
    Tell("| ")
    if npc.num ~= nil and npc.num ~= "" then
      ColourTell("cyan", "black", npc.num .. string.rep(" ", num_len - #npc.num - 1))
    else
      Tell(string.rep(" ", num_len - 1))
    end
    Tell("| ")
    if npc.race ~= nil and npc.race ~= "" then
      ColourTell("green", "black", npc.race .. string.rep(" ", race_len - #npc.race - 1))
    else
      Tell(string.rep(" ", race_len - 1))
    end
    Note("|")
  end

  if #filtered_npcs <= 0 then
    local no_npcs = "You can't feed that recipe to any NPCs right now!"
    Tell("| ")
    ColourTell("cyan", "black", no_npcs .. string.rep(" ", total_len - #no_npcs - 1))
    Note("|")
  end

  Note("." .. string.rep("-", total_len) .. ".")
  SendNoEcho("")
end

function ClickTrackedIngredients()
  local longest = getLongestIngredientName(config.tracked_ingredients)
  local total_len = longest + 18
  if longest > 0 then
    Note("." .. string.rep("-", total_len) .. ".")
    Note("| Ingredient" .. string.rep(" ", longest - 9) .. "| Find | Delete |")
    Note("." .. string.rep("-", longest + 2) .. ".------.--------.")
    for ing, t in pairs(config.tracked_ingredients) do
      ing = Trim(ing:lower())
      Tell("| ")
      ColourTell("white", "black", ing .. string.rep(" ", longest - #ing))
      Tell(" | ")
      Hyperlink("!!" .. GetPluginID() .. ":FindIngredient(" .. ing .. ")", "find", "Find ingredient", "cyan", "black", false)
      Tell(" | ")
      Hyperlink("!!" .. GetPluginID() .. ":TrackPouchIngredient(" .. ing .. ")", "delete", "Stop tracking this ingredient", "red", "black", false)
      Note(" |")
    end
  else
    local none_message = "No ingredients are currently being tracked in the pouch of plenitude."
    longest = #none_message
    total_len = longest
    Note("." .. string.rep("-", total_len) .. ".")
    Tell("| ")
    ColourTell("white", "black", none_message)
    Tell(" |")
  end

  Note("." .. string.rep("-", total_len) .. ".")
  local line = "Track New Ingredient"
  local padding = total_len - #line
  local left_padding = math.floor(padding / 2)
  local right_padding = padding - left_padding

  Tell("|" .. string.rep(" ", left_padding))
  Hyperlink("!!" .. GetPluginID() .. ":ClickTrackIngredient()", line, "", "white", "black", false)
  Note(string.rep(" ", right_padding - 1) .. " |")
  Note("." .. string.rep("-", total_len) .. ".")
  SendNoEcho("")
end

function getLongestIngredientName(ingredients)
  local longest_name = 0
  if ingredients ~= nil and type(ingredients) == "table" then
    for ingredient, tracked in pairs(ingredients) do
      if tracked and ingredient and #ingredient > longest_name then
        longest_name = #ingredient
      end
    end
  end
  return longest_name
end

function ClickTrackIngredient()
  local ingredient = utils.inputbox("What is the exact name of the ingredient?", "Track new ingredient", "")
  if ingredient ~= nil and Trim(ingredient) ~= 0 then
    ingredient = Trim(ingredient)
    config.tracked_ingredients[ingredient] = not config.tracked_ingredients[ingredient]
    if config.tracked_ingredients[ingredient] then
      ColourNote("green", "black", "Tracking " .. ingredient .. " in pouch of plenitude.")
    else
      ColourNote("red", "black", "Stopped tracking " .. ingredient .. " in pouch of plenitude.")
    end
    serialization_helper.SaveSerializedVariable(character_name .. "_cooking_config", config)
  end
end

function showCookingAsList()
  local total_tracked = 0
  for _, recipe in pairs(tracked_recipes) do
    if total_tracked == 0 then
      Note("You are currently tracking the following recipes:")
    end
    if recipe.name and recipe.name ~= "" then
      total_tracked = total_tracked + 1
      ColourTell("cyan", "black", " * ")
      ColourTell("white", "black", recipe.name:upper())
      ColourTell("gray", "black", " [")
      Hyperlink("!!" .. GetPluginID() .. ":ShowNpcs(" .. recipe.name .. ")", "npcs", "Show NPCs that will eat this", "green", "black", false)
      ColourTell("gray", "black", "]")
      ColourTell("gray", "black", " [")
      Hyperlink("!!" .. GetPluginID() .. ":DoClearRecipe(" .. recipe.name .. ")", "clear", "Clear", "orange", "black", false)
      ColourTell("gray", "black", "]")
      ColourTell("gray", "black", " [")
      Hyperlink("!!" .. GetPluginID() .. ":DoRemoveRecipe(" .. recipe.name .. ")", "X", "Delete", "red", "black", false)
      ColourNote("gray", "black", "]")
      showEaten(recipe.eaten)
    end
  end
  if total_tracked == 0 then
    Note("You are not currently tracking any recipes.")
  end
  Tell("-- type '")
  ColourTell("white", "black", "cooking track ")
  ColourTell("silver", "black", "<recipe name>")
  ColourTell("white", "black", " c:")
  ColourTell("silver", "black", "<consumer name>")
  Note("' to track a new recipe and/or consumer --")

  Tell("-- type '")
  Hyperlink("cooking npcs", "cooking npcs", "", "white", "black", false)
  Note("' to view npcs that will eat your food --")

  if config.automate_pouch then
    Tell("-- type '")
    Hyperlink("cooking pouch track", "cooking pouch track", "", "white", "black", false)
    Note("' to view your tracked ingredients --")
  end
end

function showEaten(eaten)
  local total_eaten = 0
  if type(eaten) == "table" then
    for _, consumer in pairs(eaten) do
      if type(consumer) == "table" then
        if consumer.name and consumer.name ~= "" then
          total_eaten = total_eaten + 1
          local formatted_name = consumer.name:gsub("(%w)(%w*)", function(a,b) return string.upper(a)..b end)
          ColourTell("magenta", "black", "  - ")
          ColourTell("white", "black", formatted_name)
          ColourNote("yellow", "black", " (" .. consumer.date .. ")")
        end
      end
    end
  end
  if total_eaten == 0 then
    ColourTell("magenta", "black", "  - ")
    ColourNote("white", "black", "no one has eaten this yet!")
  end
end

function TrackRecipe(args)
  local recipe_name, consumer = args:match("^(.-)%s+c:(.+)$")
  if not recipe_name then recipe_name = args end

  if recipe_name == nil or Trim(recipe_name) == "" then
    Note("You must specify a recipe name to track.")
    return
  end

  recipe_name = Trim(recipe_name)
  if not tracked_recipes[recipe_name:upper()] then
    local found = false
    for _, recipe in pairs(tracked_recipes) do
      if string.find(recipe.name:upper(), recipe_name:upper()) ~= nil then
        recipe_name = recipe.name
        found = true
        break
      end
    end
    if not found then tracked_recipes[recipe_name:upper()] = { name = recipe_name, eaten = { } } end
  end

  if consumer ~= nil and Trim(consumer) ~= "" then
    consumer = Trim(consumer)
    if tracked_recipes[recipe_name:upper()].eaten[consumer:upper()] then
      Note("Consumer '" .. consumer .. "' has already eaten '" .. recipe_name .. "'")
    else
      tracked_recipes[recipe_name:upper()].eaten[consumer:upper()] = { name = consumer, date = os.date('%Y-%m-%d %H:%M:%S') }
      Note("Consumer '" .. consumer .. "' has been recorded as having eaten '" .. recipe_name .. "'")
    end
  else
    Note("Started tracking '" .. recipe_name .. "'")
  end

  serialization_helper.SaveSerializedVariable(character_name .. "_cooking_recipes", tracked_recipes)
end

function DoClearRecipe(args)
  ClearRecipe(args, false)
end

function DoRemoveRecipe(args)
  ClearRecipe(args, true)
end

function ClearRecipe(args, delete)
  if Trim(args) == "" then
    for _, r in ipairs(tracked_recipes) do
      if delete then
        tracked_recipes[r.name:upper()] = nil
        Note("All tracked recipes have been removed from tracking.")
      else
        tracked_recipes[r.name:upper()].eaten = {}
        Note("All tracked recipes have been cleared of all consumers.")
      end
    end
  else
    local recipe_name = Trim(args)
    if tracked_recipes[recipe_name:upper()] then
      if delete then
        tracked_recipes[recipe_name:upper()] = nil
        Note("Recipe '" .. recipe_name .. "' has been removed from tracking.")
      else
        tracked_recipes[recipe_name:upper()].eaten = {}
        Note("Recipe '" .. recipe_name .. "' has been cleared of all consumers.")
      end
    else
      Note("Recipe '" .. recipe_name .. "' is not being tracked.")
    end
  end

  serialization_helper.SaveSerializedVariable(character_name .. "_cooking recipes", tracked_recipes)
end

function CleanRecipe(args)
  local cleaned = false
  args = Trim(args or ""):upper()
  for _, recipe in ipairs(tracked_recipes) do
    if args == "" or args == "ALL" or string.find(recipe.name:upper(), args) ~= nil then
      local consumers = {}
      for _, consumer in ipairs(recipe.eaten) do
        consumers[consumer.name:upper()] = consumer
      end

      local dupes = #recipe.eaten - #consumers
      if dupes > 0 then
        Note("Cleaned up '" .. recipe.name .. "' removing " .. dupes .. " duplicates.")
        tracked_recipes[recipe.name:upper()].eaten = consumers
        cleaned = true
      end
    end
  end

  if not cleaned then
    Note("No duplicates found for '" .. (args == "" and "all recipes" or args) .. "'")
  else
    serialization_helper.SaveSerializedVariable(character_name .. "_cooking recipes", tracked_recipes)
  end
end

function CheckNpcProgress(npc_name)
  if npc_names[npc_name:lower()] then
    for _, recipe in pairs(tracked_recipes) do
      if not recipe.eaten[npc_name:upper()] then
        ColourTell("yellow", "black", npc_name .. " has not yet eaten your " .. recipe.name .. "! [")
        Hyperlink("!!" .. GetPluginID() .. ":TryFeedNpc(" .. recipe.name .. "," .. npc_name .. ")", "FEED", "try to feed " .. Trim(recipe.name) .. " to " .. npc_name, "white", "black", false)
        ColourNote("yellow", "black", "]")
      end
    end
  end
end

function TryFeedNpc(feed)
  local recipe_name, npc_name = feed:match("^(.-),(.+)$")
  if not recipe_name or not npc_name then
    Note("Invalid feed command.")
    return
  end
  Execute("get '" .. recipe_name .. "' " .. config.storage_container)
  Execute("give '" .. recipe_name .. "' '" .. npc_name .. "'")
end

function ShowNpcs(filter)
  local filtered_npcs = {}
  if filter == nil or Trim(filter) == "" then
    filtered_npcs = npcs
  else
    for _, recipe in pairs(tracked_recipes) do
      if recipe ~= nil and string.find(recipe.name:upper(), Trim(filter:upper())) ~= nil then
        for _, npc in ipairs(npcs) do
          if not recipe.eaten[npc.name:upper()] then
            table.insert(filtered_npcs, npc)
          end
        end
        break
      end
    end
  end

  showSpecificNpcs(filtered_npcs)
end

function Configure(args)
  if not args or Trim(args) == "" then
    local ingredients_text, ingredients_text_display = "", ""
    for ing, tracked in pairs(config.tracked_ingredients) do
      if tracked then
        if ingredients_text ~= "" then ingredients_text = ingredients_text .. ", " end
        ingredients_text = ingredients_text .. ing
      end
    end
    ingredients_text_display = ingredients_text
    if #ingredients_text > 20 then ingredients_text_display = ingredients_text:sub(1, 17) .. "..." end

    local config_options = {
      Options = {
        pouchname = { sort = 0, type = "text", label = "Pouch Name", value = config.pouchname, raw_value = config.pouchname },
        storage_container = { sort = 1, type = "text", label = "Container", value = config.storage_container, raw_value = config.storage_container },
        tracked_ingredients = { sort = 2, type = "text", label = "Ingredients (comma-separated)", value = ingredients_text_display, raw_value = ingredients_text },
        automate_pouch = { sort = 3, type = "bool", label = "Automate (open, loot, close)", raw_value = config.automate_pouch },
        enableonstart = { sort = 4, type = "bool", label = "Enable on Start", raw_value = config.enableonstart },
        autoupdate = { sort = 5, type = "bool", label = "Auto-Update on Close", raw_value = config.autoupdate },
        show_grid = { sort = 6, type = "bool", label = "Show as Grid", raw_value = config.show_grid },
        logging = { sort = 7, type = "bool", label = "Verbose Logging", raw_value = config.logging },        
      }
    }

    config_window.Show(config_options, configureDone)
  else
    local args_split = utils.split(Trim(args), " ", 1)
    local option, value = Trim(args_split[1]:lower()), Trim(args_split[2] or "")
    
    if option == "container" then
      if Trim(value) == "" then 
        value = utils.inputbox("Container", "Enter the name of the container you store your ingredients in:", config.storage_container) 
      end
      if value ~= nil then configureDone("Options", "storage_container", { label = "Container", raw_value = value }) end
    elseif option == "pouchname" then
      if Trim(value) == "" then 
        value = utils.inputbox("Pouch Name", "Enter the name of your pouch of plenitude:", config.pouchname) 
      end
      if value ~= nil then configureDone("Options", "pouchname", { label = "Pouch Name", raw_value = value }) end
    elseif option == "ingredients" then
      if Trim(value) == "" then 
        value = utils.inputbox("Track Ingredients", "Enter a comma-separated list of ingredients to save when automating the pouch of plenitude:", table.concat(config.tracked_ingredients, ", ")) 
      end
      if value ~= nil then configureDone("Options", "tracked_ingredients", { label = "Ingredients", raw_value = value }) end
    elseif option == "automate" then
      if Trim(value) == "" then
        value = not config.automate_pouch
      else
        value = (value:lower() == "true" or value:lower() == "yes" or value:lower() == "on")
      end
      if value ~= nil then configureDone("Options", "automate_pouch", { label = "Automate Pouch", raw_value = value }) end
    elseif option == "autoupdate" then
      if Trim(value) == "" then
        value = not config.autoupdate
      else
        value = (value:lower() == "true" or value:lower() == "yes" or value:lower() == "on")
      end
      if value ~= nil then configureDone("Options", "autoupdate", { label = "Auto-Update on Close", raw_value = value }) end
    elseif option == "enableonstart" then
      if Trim(value) == "" then
        value = not config.enableonstart
      else
        value = (value:lower() == "true" or value:lower() == "yes" or value:lower() == "on")
      end
      if value ~= nil then configureDone("Options", "enableonstart", { label = "Enable on Start", raw_value = value }) end
    elseif option == "logging" then
      if Trim(value) == "" then
        value = not config.logging
      else
        value = (value:lower() == "true" or value:lower() == "yes" or value:lower() == "on")
      end
      if value ~= nil then configureDone("Options", "logging", { label = "Verbose Logging", raw_value = value }) end
    elseif option == "showgrid" or option == "grid" then
      if Trim(value) == "" then
        value = not config.show_grid
      else
        value = (value:lower() == "true" or value:lower() == "yes" or value:lower() == "on")
      end
      if value ~= nil then configureDone("Options", "show_grid", { label = "Show as Grid", raw_value = value }) end
    else
      Note("Unknown configuration option: " .. option)
      Note("Available options: container, ingredients, automate, autoupdate, showgrid, logging")
      Note("Use 'cooking config' to see and change all settings.")
    end
  end  
end

function configureDone(group_id, option_id, config_changed)
  if option_id == "tracked_ingredients" then
    config.tracked_ingredients = {}
    for _, ingredient in ipairs(utils.split(Trim(config_changed.raw_value):lower(), ",")) do
      ingredient = Trim(ingredient:lower())
      if ingredient ~= "" then
        config.tracked_ingredients[ingredient] = true
      end
    end
  else
    config[option_id] = config_changed.raw_value
  end

  local changed_value = tostring(config_changed.raw_value)
  if type(config_changed.raw_value) == "boolean" then changed_value = (config_changed.raw_value and "enabled" or "disabled") end
  Note(config_changed.label .. " has been updated to: " .. changed_value)

  if config_changed.label == "Automate Pouch" then
    if config.automate_pouch then
      EnableTriggerGroup("cooking_pouch", true)
      LootPouch()
    else
      EnableTriggerGroup("cooking_pouch", false)
    end
  end

  serialization_helper.SaveSerializedVariable(character_name .. "_cooking_config", config)

  local config_options = {
    Options = {
      pouchname = { sort = 0, type = "text", label = "Pouch Name", value = config.pouchname, raw_value = config.pouchname },
      storage_container = { sort = 1, type = "text", label = "Container", value = config.storage_container, raw_value = config.storage_container },
      tracked_ingredients = { sort = 2, type = "text", label = "Ingredients (comma-separated)", value = ingredients_text_display, raw_value = ingredients_text },
      automate_pouch = { sort = 3, type = "bool", label = "Automate (open, loot, close)", raw_value = config.automate_pouch },
      enableonstart = { sort = 4, type = "bool", label = "Enable on Start", raw_value = config.enableonstart },
      autoupdate = { sort = 5, type = "bool", label = "Auto-Update on Close", raw_value = config.autoupdate },
      show_grid = { sort = 6, type = "bool", label = "Show as Grid", raw_value = config.show_grid },
      logging = { sort = 7, type = "bool", label = "Verbose Logging", raw_value = config.logging },
    }
  }

  config_window.Update(config_options)
end

function SearchCurrentRecipe()
  if current_recipe == nil or current_recipe.name == nil or #current_recipe.name == 0 or #current_recipe.ingredients == 0 then
    Note("No recipe is currently being tracked. Use 'cooking search' after viewing a recipe card.")
    return
  end

  search_count = 0
  search_found = { }
  if not cooking then
    Note("Searching for ingredients to cook " .. current_recipe.name .. ", please wait...")
  end
  
  EnableTriggerGroup("quick_cooking", true)
  StartQuickCookingSearch()
end

function GetAll(container)
  if current_recipe == nil or current_recipe.name == nil or #current_recipe.name == 0 or #current_recipe.ingredients == 0 then
    Note("No recipe is currently being tracked. Use 'cooking getall' after viewing a recipe card.")
    return
  end

  if container == nil or container == "" then
    container = Trim(config.storage_container)
  end
  
  Note("Getting all ingredients for " .. current_recipe.name .. " from " .. container .. "...")
  
  local wait_time = .5
  for _, i in ipairs(current_recipe.ingredients) do
    DoAfterSpecial(wait_time, "getIngredient(\"" .. i .. "\", \"" .. container .. "\")", sendto.script)
    wait_time = wait_time + .5
  end
end

function getIngredient(ingredient, container)
  if config.logging then
    Send("get \"" .. ingredient .. "\" " .. container)
  else
    SendNoEcho("get \"" .. ingredient .. "\" " .. container)
  end
end

function doFinalCook()
  if cooking then
    if config.logging then
      Send("cook " .. current_recipe.name)
      Send("put '" .. current_recipe.name .. "' " .. Trim(config.storage_container))
    else
      SendNoEcho("cook " .. current_recipe.name)
      SendNoEcho("put '" .. current_recipe.name .. "' " .. Trim(config.storage_container))
    end
  end
end

function FindIngredient(ingredient)
  if ingredient == nil or Trim(ingredient) == "" then
    Note("You must specify an ingredient to search for.")
    return
  end

  if db ~= nil then
    pcall(function() db:close() end)
    db = nil
  end
  db = assert(sqlite3.open(GetInfo(66) .. "recipes.db"))

  Note("Searching DB for '" .. ingredient .. "'")
  local found_ingredients = {}
  for row in db:nrows(string.format("SELECT area, details, notes FROM ingredients WHERE name = '" .. Trim(ingredient) .. "'")) do
    found_ingredients[#found_ingredients + 1] = row
  end

  if #found_ingredients == 0 then
    Note("No results found for '" .. ingredient .. "'.")
  else
    Note("Found " .. #found_ingredients .. " result(s) for '" .. ingredient .. "':")
    for _, row in ipairs(found_ingredients) do
      displayIngredient(row)
    end
  end
end

function displayIngredient(row)
  ColourTell("cyan", "black", " * ")
  if row.area ~= nil and #row.area > 0 then
    ColourTell("white", "black", row.area)
  else
    ColourTell("red", "black", "UNKNOWN")
  end 
    
  ColourTell("silver", "black", " - ")

  if row.details ~= nil and #row.details > 0 then
    ColourTell("white", "black", row.details)
    if row.notes ~= nil and #row.notes > 0 then
      ColourTell("white", "black", "(" .. row.notes .. ")")
    end
  elseif row.notes ~= nil and #row.notes > 0 then
    ColourTell("white", "black", row.notes)
  end

  Note("")
end

function TrackPouchIngredient(ingredient)
  if ingredient and Trim(ingredient) ~= "" then
    ingredient = Trim(ingredient:lower())
    if ingredient == "clear" then
      config.tracked_ingredients = {}
      Note("Cleared all ingredients from being tracked.")
    elseif ingredient == "clean" then
      cleanContainerOfIngredients()
    else
      config.tracked_ingredients[ingredient] = not config.tracked_ingredients[ingredient]
      if config.tracked_ingredients[ingredient] then
        Note("Tracking " .. ingredient .. " in pouch of plenitude.")
      else
        Note("Stopped tracking " .. ingredient .. " in pouch of plenitude.")
      end
    end
    serialization_helper.SaveSerializedVariable(character_name .. "_cooking_config", config)
  else
    local t_count = 0
    for ing, t in pairs(config.tracked_ingredients) do
        ing = Trim(ing:lower())
        if t_count == 0 then
          Note("Tracked ingredients in pouch of plenitude:")
        end
        if t then
          ColourTell("silver", "black", " * ")
          ColourTell("white", "black", ing)
          ColourTell("gray", "black", " [")
          Hyperlink("!!" .. GetPluginID() .. ":TrackPouchIngredient(" .. ing .. ")", "X", "Clear", "red", "black", false)
          ColourNote("gray", "black", "]")
          
          t_count = t_count + 1
        end
    end
    if t_count == 0 then
      Note("No ingredients are currently being tracked in the pouch of plenitude.")
    else
      Note("A total of " .. t_count .. " ingredients are being tracked.")
    end
    Note("You can toggle tracking of an ingredient with 'cooking pouch track <ingredient>'")
  end
end

function cleanContainerOfIngredients()
  EnableTriggerGroup("cleaning_ingredients", true)
  SendNoEcho("look '" .. config.storage_container .. "'")  
  DoAfterSpecial(2, "endCleanCapture()", sendto.script)
end

function startCleanCapture()
  clean_started = true
  clean_captured = {}
end

function cleanCapture(item)
  if clean_started then
    item = Trim(item:gsub("%s*%b()", ""))
    if item ~= "" then
      clean_captured[item] = (config.tracked_ingredients[item] == true) or tracked_recipes[item:upper()] ~= nil
    end
  end
end

function endCleanCapture()
  EnableTriggerGroup("cleaning_ingredients", false)
  if clean_started then
    clean_started = false
    for item, tracked in pairs(clean_captured) do
      if not tracked then
        SendNoEcho("get all.'" .. item .. "' " .. config.storage_container)
        SendNoEcho("drop all.'" .. item .. "'")
      end
    end
  end  
end

function StartQuickCookingSearch()
  quick_cooking_ingredients = {}
  checking_ingredients = true
  EnableTriggerGroup("quick_cooking", true)
  SendNoEcho("look '" .. config.storage_container .. "'")
  DoAfterSpecial(.2, "EndQuickCookingSearch()", sendto.script)
end

function EndQuickCookingSearch()
  checking_ingredients = false
  EnableTriggerGroup("quick_cooking", false)
  local cooking_total = 0
  for _, i in ipairs(current_recipe.ingredients) do
    local ing = Trim(i:lower())
    if quick_cooking_ingredients[ing] then
      local available = quick_cooking_ingredients[ing]
      if cooking_total == 0 or available < cooking_total then
        cooking_total = available
      end
      if not cooking then 
        Tell("[")
        Hyperlink("!!" .. GetPluginID() .. ":FindIngredient(" .. ing .. ")", "?", "Find", "cyan", "black", false)
        Tell("] ")
        ColourTell("lightgray", "black", "Found ")
        ColourTell("white", "black", available)
        ColourTell("lightgray", "black", " matches for ")
        ColourTell("silver", "black", ing)
        ColourNote("lightgray", "black", ".")
      end
    else
      cooking_total = -1
      if not cooking then 
        Tell("[")
        Hyperlink("!!" .. GetPluginID() .. ":FindIngredient(" .. ing .. ")", "?", "Find", "cyan", "black", false)
        Tell("] ")
        ColourTell("lightgray", "black", "Found ")
        ColourTell("red", "black", "0")
        ColourTell("lightgray", "black", " matches for ")
        ColourTell("silver", "black", ing)
        ColourNote("lightgray", "black", ". ")
      else
        Note("You need " .. ing .. " in order to cook " .. current_recipe.name .. ".")
      end
    end
  end

  if not cooking then return end

  if cooking_total > 0 then
    if (cooking_infinite) or (cooking_total < cooking_amount) then
      cooking_amount = cooking_total
      if cooking_infinite then
        cooking_infinite = false
      end
    end

    if cooking_amount < cooking_total then
      ColourNote("white", "black", "Cooking " .. current_recipe.name .. " " .. cooking_amount .. " times. (" .. cooking_total .. " possible with your current ingredients)")
    else
      ColourNote("white", "black", "Cooking " .. current_recipe.name .. " " .. cooking_amount .. " times.")
    end
    
    local wait_time = .3
    for t = 1, cooking_amount do
      for _, i in ipairs(current_recipe.ingredients) do
        DoAfterSpecial(wait_time, "getIngredient(\"" .. i .. "\", \"" .. config.storage_container .. "\")", sendto.script)
        wait_time = wait_time + .3
      end
      DoAfterSpecial(wait_time, "doFinalCook()", sendto.script)
    end

    DoAfterSpecial(wait_time + .3, "endCook()", sendto.script)
  end
end

function CheckIfIngredient(line)
  if checking_ingredients then
    local cnt, ing, fresh = line:match("^%s*%(?%s*(%d*)%s*%)?%s*([^%(%)]+)%s*%(?([^%)]*)%)?%s*$")
    if not ing then return end
    cnt = tonumber(cnt) or 1
    ing = Trim(ing:lower())
    local cur = quick_cooking_ingredients[ing] or 0
    quick_cooking_ingredients[ing] = cur + cnt
  else
    EnableTriggerGroup("quick_cooking", false)
  end
end

function CookRecipe(times)
  if current_recipe == nil or current_recipe.name == nil or #current_recipe.name == 0 then
    Note("No recipe is currently being tracked. Try again after viewing a recipe card.")
    return
  end

  cooking_amount = tonumber(times) or 1

  if cooking_amount <= 0 then 
    cooking_infinite = true 
  else
    cooking_infinite = false
  end

  cooking = true
  
  SearchCurrentRecipe()
end

function ShowRecipe()
  if current_recipe == nil then
    Note("Look at an index card first!")
  else
    Note("The recipe for " .. current_recipe.name .. " is: ")
    for _, i in ipairs(current_recipe.ingredients) do
      local ing = Trim(i:lower())
      Note(" - " .. ing)
    end
  end
end

function endCook()
  cooking = false
  cooking_amount = 0
  cooking_infinite = false
  Note("Cooking process complete.")
end

--------------
-- triggers --
--------------

function AddNpcTracking(npc, recipe)
  if npc_names[Trim(npc:lower())] then
    TrackRecipe(recipe .. " c:" .. npc)
    last_npc_food = Trim(recipe:lower())
  end
end

function RemoveLastNpc(npc)
  for _, recipe in pairs(tracked_recipes) do
    if string.find(recipe.name:upper(), last_npc_food:upper()) ~= nil then
      local eaten = tracked_recipes[last_npc_food:upper()].eaten
      if eaten[Trim(npc:upper())] then
        eaten[Trim(npc:upper())] = nil
        Tell("Consumer '" .. npc .. "' has been removed from the '" .. last_npc_food .. "' list of consumers. [")
        Hyperlink("!!" .. GetPluginID() .. ":TryFeedNpc(" .. last_npc_food .. "," .. npc .. ")", "try again", "try to feed " .. Trim(last_npc_food) .. " to " .. npc, "white", "black", false)
        Note("]")
      end
      break
    end
  end
end

function StartRecipeCapture(recipe_name)
  if recipe_name == nil or recipe_name == "" then
    return
  end

  DisplayTool(recipe_name)

  search_containers = {}
  search_found = {}
  search_count = 0
  current_recipe = { name = recipe_name, ingredients = { } }
  EnableTriggerGroup("get_recipe", true)
end

function DisplayTool(recipe_name)
  if (requires_oven[recipe_name]) then
    ColourTell("lightgray", "black", "You need an ")
    ColourTell("yellow", "black", "oven")
    ColourNote("lightgray", "black", " to cook this.")
  elseif (requires_griddle[recipe_name]) then
    ColourTell("lightgray", "black", "You need a ")
    ColourTell("yellow", "black", "griddle")
    ColourNote("lightgray", "black", " to cook this.")
  elseif (requires_mixing_bowl[recipe_name]) then
    ColourTell("lightgray", "black", "You need a ")
    ColourTell("yellow", "black", "mixing bowl")
    ColourNote("lightgray", "black", " to cook this.")
  elseif (requires_cauldron[recipe_name]) then
    ColourTell("lightgray", "black", "You need a ")
    ColourTell("yellow", "black", "cauldron")
    ColourNote("lightgray", "black", " to cook this.")
  elseif (requires_icebox[recipe_name]) then
    ColourTell("lightgray", "black", "You need an ")
    ColourTell("yellow", "black", "icebox")
    ColourNote("lightgray", "black", " to cook this.")
  end
end

function AddIngredientToRecipe(ingredient, trigger_style_runs, line)
  local fgcol = "lightgray"
  local bgcol = "black"
  for i = 1, #trigger_style_runs do
    fgcol = RGBColourToName(trigger_style_runs[i].textcolour)
    bgcol = RGBColourToName(trigger_style_runs[i].backcolour)
    ColourTell(fgcol, bgcol, trigger_style_runs[i].text)
  end

  ingredient = Trim(ingredient:lower())
  if config.automate_pouch and not config.tracked_ingredients[ingredient] then
    ColourTell(fgcol, bgcol, " [")
    Hyperlink("!!" .. GetPluginID() .. ":TrackPouchIngredient(" .. ingredient .. ")", "+", "add " .. Trim(ingredient) .. " to tracked ingredients", "lightgreen", "black", false)
    ColourTell(fgcol, bgcol, "]")
  end

  Note("")

  if current_recipe == nil or current_recipe.name == nil or #current_recipe.name == 0 then
    return
  end

  table.insert(current_recipe.ingredients, ingredient)
end

function EndRecipeCapture()
  EnableTriggerGroup("get_recipe", false)
  if current_recipe.name ~= nil and #current_recipe.name > 0 and config.storage_container ~= nil and #config.storage_container > 0 then
    Note("")
    Tell("[")
    Hyperlink("cooking search", "Search", "Search entire inventory for ingredients", "silver", "black", false)
    if not tracked_recipes[current_recipe.name:upper()] then
      Tell("] [")
      Hyperlink("cooking track " .. current_recipe.name, "Track", "Track this recipe", "silver", "black", false)
    end
    Tell("] - [")
    Hyperlink("!!" .. GetPluginID() .. ":CookRecipe(1)", "Cook 1", "Cook " .. Trim(current_recipe.name), "silver", "black", false)
    Tell("] [")
    Hyperlink("!!" .. GetPluginID() .. ":CookRecipe(0)", "Cook All", "Cook " .. Trim(current_recipe.name) .. " as many times as you can!", "silver", "black", false)
    Tell("] - ")
    ColourTell("silver", "black", "Get All:")
    Tell(" [")
    Hyperlink("cooking getall " .. config.storage_container, config.storage_container, "Take all the ingredients you need from your container", "silver", "black", false)
    Tell("] - ")
    ColourTell("silver", "black", "Pouch: ")
    Tell("[")
    Hyperlink("!!" .. GetPluginID() .. ":AddRecipeToPouch()", "Track All", "", "silver", "black", false)
    Tell("] - [")
    Hyperlink("!!" .. GetPluginID() .. ":ClearPouch()", "Clear", "", "silver", "black", false)
    Note("]")
  end
end

function SearchFoundIngredient(ingredient, location)
  if search_found[ingredient] == nil then 
    search_found[ingredient] = 1
    search_count = search_count + 1 
    checkIfDone()
  else
    search_found[ingredient] = search_found[ingredient] + 1
  end

  search_containers[location] = true
end

function SearchNotFoundIngredient()
  search_count = search_count + 1
  checkIfDone()
end

function checkIfDone()
  if search_count == #current_recipe.ingredients then
    DoAfterSpecial(1, "finishSearch()", sendto.script)
  end
end

function finishSearch()
  EnableTriggerGroup("search_recipe", false)

  local not_found = {}
  for _, ingredient in ipairs(current_recipe.ingredients) do
    if not search_found[ingredient] then
      table.insert(not_found, ingredient)
    else
      if search_found[ingredient] < cooking_amount then
        cooking_amount = search_found[ingredient]
      end
    end
  end
  
  if #not_found > 0 then
    if cooking then
      cooking_infinite = false
      cooking = false
      cooking_amount = 0
      Note("Not enough ingredients to cook " .. current_recipe.name .. ".")
    end

    ColourTell("silver", "black", "You need: ")
    for idx, i in ipairs(not_found) do
      Hyperlink("cooking find " .. i, "[" .. i .. "]", "Find", "white", "black", false)
      if idx == #not_found then
        ColourTell("silver", "black", ".")
      else
        ColourTell("silver", "black", ", ")
      end
    end
    Note("")
  else
    if cooking then
      if search_count < 10 and cooking_infinite then
        cooking_infinite = false
      end
      GetAll()
      return
    end

    ColourNote("white", "black", "You have all the ingredients required!")
    Tell("You can find them: ")
    for k, v in pairs(search_containers) do
      ColourTell("cyan", "black", " * ")
      ColourNote("silver", "black", "in" .. k)      
    end

    if current_recipe.name ~= nil and #current_recipe.name > 0 then
      Hyperlink("cook " .. Trim(current_recipe.name), "[Cook]", "", "silver", "black", false)
      Tell(" - ")
    end
    ColourTell("silver", "black", "Get from: ")
  
    Hyperlink("cooking getall " .. config.storage_container, "[" .. config.storage_container .. "]", "", "silver", "black", false)
  end
end

function DisplayPouchStatus(trigger_style_runs, line)
  if not config then return end
  local fgcol = "lightgray"
  local bgcol = "black"
  local status = "disabled"
  if config.automate_pouch then
    status = "enabled"
  end  
  for i = 1, #trigger_style_runs do
    fgcol = RGBColourToName(trigger_style_runs[i].textcolour)
    bgcol = RGBColourToName(trigger_style_runs[i].backcolour)
    local style_text = trigger_style_runs[i].text
    if string.find(style_text, "pouch of plenitude") then
      local pouch_commands = "examine 'a pouch of plenitude'|look in 'a pouch of plenitude'|wear 'a pouch of plenitude'|drop 'a pouch of plenitude'|open 'a pouch of plenitude'|close 'a pouch of plenitude'|eat 'a pouch of plenitude'|drink 'a pouch of plenitude'|empty 'a pouch of plenitude'|light 'a pouch of plenitude'|extinguish 'a pouch of plenitude'|use 'a pouch of plenitude'"
      local pouch_tooltips = "Right mouse click to act on this item|Examine a pouch of plenitude (new)|Look inside a pouch of plenitude (new)|Wear/Hold a pouch of plenitude (new)|Drop a pouch of plenitude (new)|Open a pouch of plenitude (new)|Close a pouch of plenitude (new)|Eat a pouch of plenitude (new)|Drink a pouch of plenitude (new)|Empty a pouch of plenitude (new)|Light a pouch of plenitude (new)|Extinguish a pouch of plenitude (new)|Use a pouch of plenitude (new)"
      Hyperlink(pouch_commands, style_text, pouch_tooltips, fgcol, bgcol, false)
    else
      ColourTell(fgcol, bgcol, trigger_style_runs[i].text)
    end
  end
  ColourTell(fgcol, bgcol, " [")
  ColourTell("white", "black", status)
  ColourNote(fgcol, bgcol, "]")
end

function LootPouch(obj)
  obj = Trim(obj or ""):lower()
  local pouchname = Trim(config.pouchname or "a pouch of plenitude"):lower()
  if obj == "" then obj = pouchname end
  if obj == pouchname and config.automate_pouch then
    if automation_temp_off then
      triggered_while_off = true
    else
      SendNoEcho("open plenitude")
      SendNoEcho("get all plenitude")
      SendNoEcho("close plenitude")
    end
  end
end

function HandlePouchIngredient(ingredient)
  if not config.automate_pouch or not ingredient or ingredient == "" then
    return
  end

  ingredient = Trim(ingredient:lower())
  
  if config.tracked_ingredients[ingredient] then
    SendNoEcho("put all.\"" .. ingredient .. "\" " .. config.storage_container)
  elseif non_food_items[ingredient] then
    SendNoEcho("drop all.\"" .. ingredient .. "\"")
  else
    pulled_food = true
  end  
end

function AddRecipeToPouch()
  if current_recipe.ingredients == nil or #current_recipe.ingredients == 0 then
    Note("You have no recipe to add to the pouch.")
    return
  end

  for _, ingredient in ipairs(current_recipe.ingredients) do
    ingredient = Trim(ingredient:lower())
    if not config.tracked_ingredients[ingredient] then
      config.tracked_ingredients[ingredient] = true
      ColourNote("green", "black", "Added " .. ingredient .. " to pouch tracking.")
    else
      ColourNote("yellow", "black", ingredient .. " is already being tracked in the pouch.")
    end
  end

  serialization_helper.SaveSerializedVariable(character_name .. "_cooking_config", config)
end

function ClearPouch()
  if #config.tracked_ingredients == 0 then
    Note("You have no tracked ingredients to clear.")
    return
  end

  config.tracked_ingredients = {}
  serialization_helper.SaveSerializedVariable(character_name .. "_cooking_config", config)
  Note("Cleared all ingredients from pouch tracking.")
end

function EndCooking()
  if cooking then
    cooking = false
    Note("An ingredient you need to cook " .. current_recipe.name .. " was not found in " .. config.storage_container .. ".")
  end
end

function StartPouchAutomation(obj)
  obj = Trim(obj or ""):lower()
  local pouchname = Trim(config.pouchname or "a pouch of plenitude"):lower()
  if obj == pouchname then
    EnableTriggerGroup("cooking_open_pouch", true)
  end
end

function StopPouchAutomation(obj)
  obj = Trim(obj or ""):lower()
  local pouchname = Trim(config.pouchname or "a pouch of plenitude"):lower()
  if obj == pouchname then
    EnableTriggerGroup("cooking_open_pouch", false)
    if pulled_food then
      SendNoEcho("drop all.food")
      pulled_food = false
    end
  end
end

function UpdatePlugin()
  if updater_installed then
    local success, updated = update_helper.Update(GetPluginInfo(GetPluginID(), 6):gsub("\\", "/"), "cooking_helper.xml")
    if success and updated then
      ColourNote("green", "black", "The '" .. GetPluginName() .. "' plugin has been updated and should be reinstalled from the plugins menu.")
    else
      Note("No updates available for '" .. GetPluginName() .. "' at this time.")
    end
  else
    ColourNote("red", "black", GetPluginName() .. ": UpdateHelper was not found. Make sure updatehelper.lua is in your lua folder.")
  end  
end

]]>

</script>

</muclient>