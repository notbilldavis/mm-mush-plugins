<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>

<plugin
   name="capture_quests"
   author="Oona"
   id="892911b648d09c18e1ecd4e6"
   language="Lua"
   purpose="show quest details in new capture tab"
   save_state="y"
   date_written="2025-06-04 18:38:09"
   requires="4.71"
   version="1.0"
   >

<description trim="y">

<![CDATA[

  Track and complete quests, orc pursuer, and crystal targets easily.

  Commands:

   * quest hint <phase> - check for hints from annwn.info that were submitted by players
   * quest time - see how long until you can do another quest, pursuer, or crystal map
   * quest clear <quest, pursuer, crystal> - clears the quest window of what you specify
   * quest remove <quest number> - removes the quest from the database
   * quest config - open the configuration window

   Note: q can be used instead of quest.

]]>

</description>

</plugin>

<aliases>

  <alias enabled="y" match="^q(?:|uest) hint (.*?)$" regexp="y" send_to="12" sequence="100">
    <send>ShowHint("%1")</send>
  </alias>

  <alias enabled="y" match="^q(?:|uest) time((r)?s)?$" regexp="y" send_to="12" sequence="100">
    <send>ShowTimes()</send>
  </alias>

  <alias enabled="y" match="^q(?:|uest) clear(.*?)$" regexp="y" send_to="12" sequence="100">
    <send>Clear("%1")</send>
  </alias>

  <alias enabled="y" match="^q(?:|uest) remove (.*?)$" regexp="y" send_to="12" sequence="100">
    <send>RemoveQuest("%1")</send>
  </alias>

  <alias match="^q(?:|uest)[ ]+(?:config|configure)\b(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>Configure("%1")</send>
  </alias>

</aliases>

<triggers>

  <trigger match="^(|[^ ]+(.*?))(\<(.+)hp (.+)sp (.+)st\>|\(.+\)) $" enabled="y" name="first_prompt" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>OnFirstPrompt()</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" name="capture_name" match="^This quest \[(.*?)\] is called \'(.*?)\'\,$" regexp="y" send_to="14" sequence="100">
    <send>StartCapturingQuest("%1", "%2")</send>
  </trigger>

  <trigger enabled="n" keep_evaluating="y" name="capture_name_refresh" match="^This quest \[(.*?)\] is called \'(.*?)\'\,$" regexp="y" omit_from_output="y" sequence="100">
  </trigger>

  <trigger match="*" keep_evaluating="y" name="capture_line" send_to="14" sequence="100">
    <send>CaptureLine("%0")</send>
  </trigger>

  <trigger enabled="n" keep_evaluating="y" name="capture_line_refresh" match="*" omit_from_output="y" sequence="100">
  </trigger>

  <trigger match="^$" keep_evaluating="y" name="capture_end" regexp="y" send_to="14" sequence="100">
    <send>StopCapturingQuest()</send>
  </trigger>  

  <trigger enabled="y" keep_evaluating="y" expand_variables="y" match="^(.*?) tells you\, \'Congratulations on the completion of thy quest\, (.*?)$" regexp="y" send_to="12" sequence="100">
    <send>FinishQuest()</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^You have run out of time for your quest\, (.*?)\.$" regexp="y" send_to="12" sequence="100">
    <send>FinishQuest() </send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^You have abandoned quest (.*?)\.$" regexp="y" send_to="12" sequence="100">
    <send>FinishQuest() </send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^You have completed a part of quest \#(.*?)\, \'(.*?)\'\!$" regexp="y" send_to="12" sequence="100">
    <send>RefreshQuest("%1") </send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^All parts of your quest \'(.*?)\' are complete\." regexp="y" send_to="12" sequence="100">
    <send>RefreshQuest("%1") </send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" omit_from_output="y" match="^  Spell Points\:(.*?)Quest Points\:(.*?)$" regexp="y" send_to="14" sequence="100">
    <send>ReplaceQuestTime(TriggerStyleRuns, "%0")</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^\'Thank you\, (.+)\!\' Tadamir the guildsman exclaims to you\. \'Here is your reward\, as promised\.\'$" regexp="y" send_to="12" sequence="100">
    <send>FinishCrystal()</send>
  </trigger>

  <trigger enabled="y" match="^\'Ekai Nosrat Sulla Garha \&quot;(.+?)\&quot;\, Setama Sulla \&quot;(.+?)\&quot;\, Ekass Armas Thran Bel Dinas\.\' the orc pursuer says(| to you)\. \'Nohsa Sulla Amata\.\'$" regexp="y" send_to="12" sequence="100">
    <send>SetPursuerTarget("%1 (%2)")</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^The orc pursuer gives you (.+)\.$" regexp="y" send_to="12" sequence="100">
    <send>FinishPursuer()</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^You give the carcass of a captive dodo to an orc woman\.$" regexp="y" send_to="12" sequence="100">
    <send>FinishPursuer()</send>
  </trigger>

  <trigger match="^The severed (.*?) of (.*?) falls to the ground\.$" enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>CheckBodyPartDrop("%1", "%2")</send>
  </trigger>

  <trigger match="^The severed (.*?) of (.*?) plops in the water\.$" enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>CheckBodyPartDrop("%1", "%2")</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100" match="^(.*?) savage\-looking orc stands here\, his every limb chained to the wall\.$">
    <send>ShowPursuerOptions()</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" multi_line="y" lines_to_match="23" regexp="y" send_to="12" sequence="100"
    match="It looks like this map depicts(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n(.*?)\n">
    <send>LocateCrystal("%2\\r\\n%3\\r\\n%4\\r\\n%5\\r\\n%6\\r\\n%7\\r\\n%8\\r\\n%9\\r\\n%&lt;10&gt;\\r\\n%&lt;11&gt;\\r\\n%&lt;12&gt;\\r\\n%&lt;13&gt;\\r\\n%&lt;14&gt;\\r\\n%&lt;15&gt;\\r\\n%&lt;16&gt;\\r\\n%&lt;17&gt;\\r\\n%&lt;18&gt;\\r\\n%&lt;19&gt;\\r\\n%&lt;20&gt;\\r\\n%&lt;21&gt;\\r\\n%&lt;22&gt;")</send>
  </trigger>

  <trigger enabled="y" keep_evaluating="y" match="^You take a (blood|small) crystal\.$" sequence="100" send_to="10">
    <send>BroadcastPlugin(2)</send>
  </trigger>

  <trigger enabled="y" match="^\* You may ask Tadamir for another map at\: (.*?)$" omit_from_output="y" regexp="y" send_to="14" sequence="100">
    <send>ReplaceCrystalTime(TriggerStyleRuns, "%0", "%1")</send>
  </trigger>

  <trigger enabled="y" name="capture_time_offset" match="^The current system time is\: (.*?)\.$" regexp="y" send_to="12" sequence="100">
    <send>SetOffset("%1")</send>
  </trigger>

</triggers>

<script>

<![CDATA[

local can_update, update_helper = pcall(require, "updatehelper")
local const_installed, consts = pcall(require, "consthelper")
local serializer_installed, serialization_helper = pcall(require, "serializationhelper")
local config_installed, config_window = pcall(require, "configuration_miniwindow")
local quest_installed, quest_window = pcall(require, "quest_miniwindow")
local searcher_installed, searcher = pcall(require, "questsearcher")

if can_update and update_helper.version == nil then
  update_helper.Update({{ local_file = GetInfo(56):gsub("\\", "/") .. "lua/updatehelper.lua", remote_file = "https://raw.githubusercontent.com/notbilldavis/mm-mush-plugins/refs/heads/main/lua/updatehelper.lua"}})
  package.loaded["updatehelper"] = nil
  can_update, update_helper = pcall(require, "updatehelper")
end

if can_update then
  if not const_installed then const_installed, consts = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/consthelper.lua") end
  if not serializer_installed then serializer_installed, serialization_helper = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/serializationhelper.lua") end
  if not config_installed then config_installed, config_window = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/configuration_miniwindow.lua") end
  if not quest_installed then quest_installed, quest_window = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/quest_miniwindow.lua") end
  if not quest_installed then searcher_installed, searcher = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/questsearcher.lua") end
end

function OnPluginInstall() pluginStart() end
function OnPluginEnable() pluginStart() end
function OnPluginConnect() pluginStart() end
function OnPluginClose() pluginStop() end
function OnPluginDisable() pluginStop() end
function OnPluginDisconnect() pluginStop() end

local quest = {}
local captured_lines = {}
local refreshing = false

function pluginStart()
  if not const_installed or not serializer_installed or not config_installed or not quest_installed or not searcher_installed then 
    ColourNote("black", "red", GetPluginName() .. ": You do not have the required files in your lua directory. Expect issues.") 
  end
  
  quest_window.Initialize()
end

function pluginStop()
  if can_update and quest_window.IsAutoUpdateEnabled() then
    CheckForUpdates()
  else
    Note("Auto-update for '" .. GetPluginName() .. "' is disabled. Enable it in the plugin configuration to receive updates.")
  end  

  quest_window.Close()
  config_window.Hide()
end

function OnFirstPrompt()
  EnableTrigger("first_prompt", false)

  DoAfterSpecial(1, "tryGetOffset()", sendto.script)
end

function tryGetOffset()
  if consts.getHourOffset() == nil then
    EnableTrigger("capture_time_offset", true)
    Note("Sending time to get hour offset from server...")
    Send("time")
  else
    EnableTrigger("capture_time_offset", false)
  end    
end

function StartCapturingQuest(num, name)
  quest_window.Clear("quest")
  captured_lines = {}
  quest = {}

  if string.find(string.lower(name), "daily quest", 1, true) ~= nil or
     string.find(string.lower(name), "weekly quest", 1, true) ~= nil or
     string.find(string.lower(name), "archon meta", 1, true) ~= nil then
    return
  end  

  EnableTrigger("capture_line", true)
  EnableTrigger("capture_end", true)

  if refreshing then
    EnableTrigger("capture_line_refresh", true)
  end
  
  addToLine("Quest ", "springgreen", "black", "quest" .. num, true)
  addToLine("[", "blue", "black", "quest" .. num, true)
  addToLine(num, "springgreen", "black", "quest" .. num, true)
  addToLine("] ", "blue", "black", "quest" .. num, true)
  addToLine(name, "springgreen", "black", "quest" .. num, true)
  addNewLine("quest" .. num, true)

  if quest.num ~= num then
    quest.num = num
    quest.name = name
    quest.phases, quest.annwn_id = searcher.GetQuestInfo(num, name)
  end
end

function CaptureLine(line)
  if (string.find(string.lower(line), string.lower("phase"), 1, true) ~= nil and string.find(string.lower(line), string.lower("metaquest"), 1, true) == nil) then
    local split = utils.split(line, ":")
    local section = split[1]
    addToLine(section, "cyan", "black", section, true)

    local color = "silver"
    local phase_text = Trim(split[2])
    local counter = ""
    if string.sub(phase_text, 1, 1) == "[" then
      local counterEnd = string.find(phase_text, "]")
      counter = string.sub(phase_text, 1, counterEnd + 1)
    end

    phase_text = phase_text:gsub("%b[]", ""):gsub("%.", ""):gsub("%s+", " "):gsub("^%s+", ""):gsub("%s+$", "")

    if string.sub(phase_text, 1, 1) == "*" then
      phase_text = string.sub(phase_text, 2, #phase_text)
      color = "dimgray"
    end

    phase_text = counter .. phase_text

    addToLine(phase_text, color, "black", section, true)
    addNewLine(section, true)
    if color ~= "dimgray" and quest.phases ~= nil then
      for i, phase in ipairs(quest.phases) do
        local check = Trim(phase.text:lower():gsub(" and keep", ""))
        local one = Trim(phase_text:lower():gsub(" and keep", ""))
        local two = Trim(string.sub(check, 1, #check - 1))
        if one == two then
          for _, item in ipairs(phase.items) do
            displayMultiParts(item, section)
          end
          for _, mob in ipairs(phase.mobs) do
            displayMultiParts(mob, section)
          end
          for _, room in ipairs(phase.rooms) do
            displayMultiParts(room, section)
          end
        end
      end
    end
  end
end

function displayMultiParts(line, section)
  local multi = string.find(line, "],")
  if multi == nil then
    addToLine("  - " .. line, "silver", "black", section, false)
    addNewLine(section, false)
  else
    addToLine("  - " .. line:sub(1, multi), "silver", "black", section, false)
    addNewLine(section, false)
    displayMultiParts(" or " .. line:sub(multi + 3, #line), section)
  end
end

function StopCapturingQuest()
  refreshing = false

  EnableTrigger("capture_line", false)
  EnableTrigger("capture_end", false)

  EnableTrigger("capture_name_refresh", false)
  EnableTrigger("capture_line_refresh", false)

  doFinalDisplay()
end

function Clear(arg)
  quest_window.Clear(Trim(arg:lower()))
end

function SetPursuerTarget(target)
  quest_window.SetPursuerTarget(target)
end

function FinishQuest()
  quest_window.Clear("quest")
  quest_window.SetQuestTime()
end

function FinishCrystal()
  quest_window.Clear("crystal")
  quest_window.SetCrystalTime()
end

function FinishPursuer()
  quest_window.Clear("pursuer")
  quest_window.SetPursuerTime()
end

function CheckBodyPartDrop(part, victim)
  quest_window.CheckBodyPartDrop(part, victim)
end

function RemoveQuest(quest_id)
  local removed = searcher.RemoveQuestFromDb(tonumber(quest_id))
  if removed then
    quest_window.Clear("quest")
    Note("Quest has been removed from the database, check quest status to retrieve it again.")
  else
    Note("Unable to remove from db.")
  end
end

function RefreshQuest(quest_id)
  if quest_id == quest.name then
    quest_id = quest.num
  elseif quest_id ~= quest.num then
    return
  end

  if string.find(quest.name, "Daily Quest") ~= nil then return end
  if string.find(quest.name, "Weekly Quest") ~= nil then return end
  if string.find(quest.name, "Archon Meta") ~= nil then return end
  
  if quest_window.IsSilentRefreshEnabled() then
    refreshing = true
    EnableTrigger("capture_name_refresh", true)
    if quest_id == nil then quest_id = quest.num end
    SendNoEcho("quest status " .. quest_id)
  end
end

function ShowHint(phase_num)
  if quest == nil or quest.phases == nil then return end
  local shown = false
  local phase = quest.phases[tonumber(phase_num)]
  if phase ~= nil and phase.hints ~= nil then
    for _, hint in ipairs(phase.hints) do
      if hint ~= nil and hint ~= "" then
        shown = true
        Note(hint)
      end
    end
  end
  
  if not shown then
    Note("No hints available for this phase.")
  end
end

function ShowTimes()
  quest_window.ShowTimes()
end

function addToLine(txt, text_color, back_color, section, is_header)
  if (not styles) then
    styles = {}
  end

  if (txt == "\r\n") then
    table.insert(captured_lines, { styles = styles, section = section, is_header = is_header})
    styles = {}
  else
    if back_color == nil then back_color = "black" end
    styles[#styles + 1] = {
      text = txt,
      textcolour = ColourNameToRGB(text_color),
      backcolour = ColourNameToRGB(back_color)
    }
  end
end

function addNewLine(section, is_header)
  addToLine("\r\n", "silver", "black", section, is_header)
end

function doFinalDisplay()
  quest_window.SetQuestInfo(quest.num, quest.name, quest.annwn_id)
  for idx, line in ipairs(captured_lines) do
    quest_window.AddLine(line.styles, line.section, line.is_header)
  end
end

function Configure(args)
  local option, value = args:match("%s-(%a-)%s-(%a-)")
  if config_installed then   
    config_window.Show(quest_window.GetConfiguration(), onConfigureDone)
  else
    -- todo
  end  
end

function onConfigureDone(group_id, option_id, config)
  quest_window.OnConfigureDone(group_id, option_id, config)
  config_window.Update(quest_window.GetConfiguration())
end

function ShowPursuerOptions()
  quest_window.ShowPursuerOptions()
end

function LocateCrystal(location)
  local crystal = searcher.LocateCrystal(location)
  if crystal == nil then
    Note("The crystal could not be found!")
  else
    Note("The crystal is located at ".. crystal)
    quest_window.SetCrystalTarget(crystal) 
    BroadcastPlugin(1, crystal)
  end
  EnableTrigger("findcrystal", false)
end

function ReplaceCrystalTime(trigger_style_runs, line, time_str)
  local converted_time, year, month, day, hour, minute, second = consts.convertToTime(time_str)
  local details = consts.getTimeDiffInMinutes(converted_time)
  local formatted_date = consts.getFormattedDateTime(year, month, day, hour, minute, second)
  local fgcol = RGBColourToName(trigger_style_runs[1].textcolour)
  local bgcol = RGBColourToName(trigger_style_runs[1].backcolour)
  ColourTell(fgcol, bgcol, "* ")
  if #trigger_style_runs > 1 then
    fgcol = RGBColourToName(trigger_style_runs[2].textcolour)
  end
  ColourTell(fgcol, bgcol, "You may ask Tadamir for another map ")
  ColourTell("white", "black", details)
  ColourTell(fgcol, bgcol, " (")
  ColourTell("white", "black", formatted_date)
  ColourNote(fgcol, bgcol, ")")  
end

function ReplaceQuestTime(trigger_style_runs, line)
  local details = "NOW!"
  if TIMES ~= nil and TIMES.QUEST_TIME ~= nil then
    details = consts.getTimeDiffInMinutes(TIMES.QUEST_TIME)
  end
  local fgcol = "lightgray"
  local bgcol = "black"
  for i = 1, #trigger_style_runs do
    fgcol = RGBColourToName(trigger_style_runs[i].textcolour)
    bgcol = RGBColourToName(trigger_style_runs[i].backcolour)
    ColourTell(fgcol, bgcol, trigger_style_runs[i].text)
  end
  ColourTell(fgcol, bgcol, " [")
  ColourTell("white", "black", details)
  ColourNote(fgcol, bgcol, "]")
end

function SetOffset(time_str)
  EnableTrigger("capture_time_offset", false)

  local input_time, year, month, day, hour, minute, second = consts.convertToTime(time_str)
  local offset_seconds = os.difftime(input_time, os.time())
  local offset_hours = math.floor(offset_seconds / 3600 + 0.5)
  hour_offset = tonumber(offset_hours)
  SetVariable("hour_offset", hour_offset)
  SaveState()
end

function CheckForUpdates()
  if can_update then
    update_helper.Update(GetPluginInfo(GetPluginID(), 6):gsub("\\", "/"), "capture_quest.xml")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/quest_miniwindow.lua")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/questsearcher.lua")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/configuration_miniwindow.lua")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/consthelper.lua")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/serializationhelper.lua")
  else
    ColourNote("red", "black", GetPluginName() .. ": UpdateHelper was not found. Make sure updatehelper.lua is in your lua folder.")
  end
end

]]>

</script>

</muclient>
