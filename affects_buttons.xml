<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>

<plugin
   name="affects_buttons"
   author="Oona"
   id="3a8348c0204a529dc99c2ba8"
   language="Lua"
   purpose="clickable buttons list that changes colors for your affects"
   save_state="y"
   date_written="2025-03-16 13:57:37"
   date_modified="2025-07-15 10:45:00"
   requires="4.71"
   version="2.1"
   >

<description trim="y">

<![CDATA[

Adds a panel you can add buttons to that will perform commands when clicked.
Buttons with an affect associated will be color-coded based on its status
This affect is typically the name of the skill/spell in lower case
Buttons without an affect will just be gray.

You can right-click a button to perform a lot of actions and you can use the
following commands to things as well, such as add buttons.

 * affects add <title> a:<affect> c:<command>
 * affects edit <title> a:<affect> c:<command>
 * affects delete <title>

<title> is what the button will say
<affect> is the affect it will try to track, it can be empty
<command> is the command to send when clicked

Using 'affects add' without any arguments will walk you through it step by step
and using 'affects edit <title>' will walk you through it that way.

 * affects move up <title>
 * affects move down <title>

This will move the button around.

 * affects broadcast
 * affects broadcast <affect>

When this affect is applied we can broadcast it for other plugins to pick it up

  * affects configure

This will open up a configuration window that will let you do all sorts of things.

A lot of these can be done by right clicking as well, also right click to set an
option as a favorite, this will add a button to auto-cast every button you have
marked if it is not casted, about to expire, or doesn't have an affect.

Some notes:

Druid affects are usually translated to non-druid spells that are exclusive so 
having a ring that gives stone skin will still show your invoke ooze as casted

This isn't 100% accurate. Some spells don't fire off events when they expire so
to be certain you are up to date you can view your affects manually at anytime
which will update the buttons

When recasting something before it expires it will try to guess the duration
based on the highest duration it's been casted. This can get weird when you do
something like cast levitation on your horse. It will think it was casted on you
and reset your meter thingy. Manually check affects to fix it.

Examples:

affects add Whirlwind a:whirlwind c:cast whirlwind
affects add Invoke Ooze a:stone skin c:invoke ooze
affects add Summon Mount a: c:cast 'summon mount'


MAKE SURE YOU TURN 'SHOW-AFFECT-SPOILERS' ON IN-GAME!

]]>

</description>

</plugin>

<aliases>

  <alias match="^affects[ ]+add(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>AddButton("%1")</send>
  </alias>

  <alias match="^affects[ ]+edit(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>EditButton("%1")</send>
  </alias>

  <alias match="^affects[ ]+delete(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>DeleteButton("%1")</send>
  </alias>

  <alias match="^affects[ ]+rename(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>RenameButton("%1", "%2")</send>
  </alias>

  <alias match="^affects[ ]+move(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>MoveButton("%1")</send>
  </alias>

  <alias match="^affects[ ]+(?:config|configure)\b(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>Configure("%1")</send>
  </alias>

  <alias match="^affects[ ]+broadcast(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>Broadcast("%1")</send>
  </alias>

  <alias match="^affects[ ]+setchar[ ]+(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>SetCharacterName("%1")</send>
  </alias>

  <alias match="^affects[ ]+cast[ ]+favorites" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>CastFavorites()</send>
  </alias>
  
  <alias match="^affects[ ]+update$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>CheckForUpdates()</send>
  </alias>

</aliases>

<triggers>

  <trigger match="^(|[^ ]+(.*?))(\<(.+)hp (.+)sp (.+)st\>|\(.+\)) $" enabled="y" name="first_prompt" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>OnFirstPrompt()</send>
  </trigger>

  <trigger match="^You are affected by the following\:$" enabled="y" name="start_affects" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>StartCapturingAffects()</send>
  </trigger>

  <trigger match="^Total of (.*?)magical(.*?) affects\.$" enabled="y" name="stop_affects" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>StopCapturingAffects()</send>
  </trigger>

  <trigger match="^(?:Spell|Affect)\:(.*?)\- Level (.*?)\, modifies (.*?) for (.*?) minute(.*?)$" enabled="y" group="get_affects" keep_evaluating="n" regexp="y" send_to="12" sequence="100">
    <send>SetAffect("%1", "%4", false)</send>
  </trigger>

  <trigger match="^(?:Spell|Affect|Disease|Prof)\:(.*?)\- Level (.*?)\, modifies (.*?)by(.*?).(.*?)$" enabled="y" group="get_affects" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>SetAffect("%1", "-1", false)</send>
  </trigger>

  <trigger match="^You have increased the duration of the spell \'(.*?)\'\.$" enabled="y" keep_evaluating="n" regexp="y" send_to="12" sequence="100">
    <send>RecastAffect("%1")</send>
  </trigger>

  <trigger match="^\[Off\: You lose (.*?)\] (.*?)\.$" enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>RemoveAffect("%1")</send>
  </trigger>

  <trigger match="^You are surrounded by an ochre glow as the last vestiges of \'(.*?)\' are burned from your body\.$" enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>RemoveAffect("%1")</send>
  </trigger>
  
  <trigger match="^(.*?) knocks (.*?) from your grip\.$" enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100" >
    <send>DisarmedBroadcast("%2")</send>
  </trigger> 

  <trigger match="^You call your familiar\, and a wary\-looking wolf appears right on cue to join you\.$" enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>SetAffect("wolf_familiar", "120")</send>
  </trigger>

  <trigger match="^There is a slight \*poof\* as an alert wolf vanishes from your inventory\.$" enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>RemoveAffect("wolf_familiar")</send>
  </trigger>

  <trigger match="^You feel relieved as the (plague|poison) is burned from your body\.$" enabled="y" keep_evaluating="y" regexp="y" send_to="12" sequence="100">
    <send>RemoveAffect("%1")</send>
  </trigger>
</triggers>

<timers>

  <timer name="affects_timer" enabled="y" second="10" offset_second="0.00" send_to="12" active_closed="y">
    <send>TimerTriggered()</send>
  </timer>

</timers>

<script>

<![CDATA[

require "gmcphelper"

local can_update, update_helper = pcall(require, "updatehelper")
local const_installed, consts = pcall(require, "consthelper")
local serializer_installed, serialization_helper = pcall(require, "serializationhelper")
local config_installed, config_window = pcall(require, "configuration_miniwindow")
local buttons_installed, buttons_window = pcall(require, "affectsbuttons_miniwindow")
local badaffects_installed, badaffects_window = pcall(require, "badaffects_miniwindow")

if can_update and update_helper.version == nil then
  update_helper.Update({{ local_file = GetInfo(56):gsub("\\", "/") .. "lua/updatehelper.lua", remote_file = "https://raw.githubusercontent.com/notbilldavis/mm-mush-plugins/refs/heads/main/lua/updatehelper.lua"}})
  package.loaded["updatehelper"] = nil
  can_update, update_helper = pcall(require, "updatehelper")
end

if can_update then
  if not const_installed then const_installed, consts = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/consthelper.lua") end
  if not serializer_installed then serializer_installed, serialization_helper = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/serializationhelper.lua") end
  if not config_installed then config_installed, config_window = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/configuration_miniwindow.lua") end
  if not buttons_installed then buttons_installed, buttons_window = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/affectsbuttons_miniwindow.lua") end
  if not badaffects_installed then badaffects_installed, badaffects_window = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/badaffects_miniwindow.lua") end
end

local notify_changes = true

function OnPluginInstall() pluginStart() end
function OnPluginEnable() pluginStart() end
function OnPluginConnect() pluginStart() end
function OnPluginClose() pluginStop() end
function OnPluginDisable() pluginStop() end
function OnPluginDisconnect() pluginStop() end

function OnPluginBroadcast(msg, id, name, text)
  if (id == "f67c4339ed0591a5b010d05b") then
    if (text == "char.affect_application_msg") then
      handleGmcpAdd()
    elseif (text == "char.affect_removal_msg") then
      handleGmcpRemove()
    elseif (text == "char.base") then
      handleGmcpCharacterName()
    end
  end
end

function pluginStart()
  if not const_installed or not serializer_installed or not config_installed or not buttons_installed or not badaffects_installed then 
    ColourNote("black", "red", GetPluginName() .. ": You do not have the required files in your lua directory. Expect issues.") 
  end
  
  EnableTrigger("first_prompt", true)
  EnableTriggerGroup("get_affects", false)
  buttons_window.Prepare()
end

function pluginStop()
  if can_update and buttons_window.IsAutoUpdateEnabled() then
    CheckForUpdates()
  else
    Note("Auto-update for '" .. GetPluginName() .. "' is disabled. Enable it in the plugin configuration to receive updates.")
  end  

  buttons_window.Close()
  badaffects_window.Close()
  config_window.Hide()
end

-----------------
--   Aliases   --
-----------------

function AddButton(args)
  local title, affect, command = getCrudArgs(args)
  buttons_window.AddButton(title, affect, command)
end

function EditButton(args)
  local title, affect, command = getCrudArgs(args)
  buttons_window.EditButton(title, affect, command)
end

function DeleteButton(title)
  buttons_window.DeleteButton(title)
end

function RenameButton(args)
  local title, new_title = nil, nil
  if string.find(args, "n:", 1, true) ~= nil then title, new_title = args:match("%s-(.+) n:(.+)%s-") 
  else title = args end
  buttons_window.RenameButton(title, new_title)
end

function getCrudArgs(args)
  if args == nil then args = "" end
  local has_affect, has_command = false, false
  if string.find(args, "a:", 1, true) ~= nil then has_affect = true end
  if string.find(args, "c:", 1, true) ~= nil then has_command = true end
  
  local title, affect, command = nil, nil, nil
  if not has_affect and not has_command then
    title = args
  elseif not has_command then
    title, affect = args:match("%s-(.+) a:(.+)%s-")
  elseif not has_affect then
    title, command = args:match("%s-(.+) c:(.+)%s-")
  else
    title, affect, command = args:match("%s-(.+) a:(.+)%s- c:(.+)%s-")
    if title == nil or affect == nil or command == nil then
      title, command, affect = args:match("%s-(.+) c:(.+)%s- a:(.+)%s-")
    end
  end

  if affect ~= nil then affect = parseAffect(affect) end
  return title, affect, command
end

function MoveButton(args)
  local direction, title = args:match("%s-(%a+) (.+)%s-") 
  if direction == nil or title == nil then 
    Note("Move a button with 'affects move (up|down) <button title>'") 
  else
    if Trim(direction:lower()) == "up" then
      buttons_window.MoveButtonUp(title)
    elseif Trim(direction:lower()) == "down" then
      buttons_window.MoveButtonDown(title)
    else
      Note("Move a button with 'affects move (up|down) <button title>'") 
    end
  end  
end

function Configure(args)
  local which, option, value = args:match("%s-(%a+)%s-(%a-)%s-(%a-)")
  if config_installed then 
    local config = {}
    if which == nil or which:sub(1, 6) == "button" then
      config.Button_Options = buttons_window.GetConfiguration()
    end
    if which == nil or which:sub(1, 8) == "negative" then
      config.Negative_Affects_Options = badaffects_window.GetConfiguration()
    end
    config_window.Show(config, buttons_window.OnConfigureDone)
  else
    
  end  
end

function Broadcast(args)
  if args == nil or Trim(args) == "" then
    buttons_window.ShowBroadcasts()
  else
    buttons_window.ToggleBroadcastAffect(Trim(args:lower()))
  end
end

function SetCharacterName(name)
  if name == nil or name == "" then
    Note("Unknown character name, set with 'affects setchar <name>'") 
  else
    buttons_window.Initialize(name)
    badaffects_window.Initialize(name)
    DoAfter(1, "affects")
  end
end

function CastFavorites()
  buttons_window.CastFavorites()
end

function CheckForUpdates()
  if can_update then
    update_helper.Update(GetPluginInfo(GetPluginID(), 6):gsub("\\", "/"), "affects_buttons.xml")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/affectsbuttons_miniwindow.lua")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/badaffects_miniwindow.lua")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/configuration_miniwindow.lua")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/consthelper.lua")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/serializationhelper.lua")
  else
    ColourNote("red", "black", GetPluginName() .. ": UpdateHelper was not found. Make sure updatehelper.lua is in your lua folder.")
  end
end

----------------
-- Triggers   --
----------------

function OnFirstPrompt()
  Execute("sendgmcp char.base")
end

function StartCapturingAffects()
  notify_changes = false
  EnableTriggerGroup("get_affects", true)
  buttons_window.Clear()
  badaffects_window.Clear()
end

function StopCapturingAffects()
  notify_changes = true
  EnableTriggerGroup("get_affects", false)
  buttons_window.Draw()
  badaffects_window.Draw()
end

function SetAffect(affect, time_str, refresh)
  local parsed_affect = parseAffect(affect)
  local converted_time = tonumber(time_str or 0) or 0  
  buttons_window.SetAffect(parsed_affect, converted_time, notify_changes, refresh)
  badaffects_window.SetAffect(parsed_affect, converted_time, refresh)
end

function RecastAffect(affect)
  local parsed_affect = parseAffect(affect)
  local est_duration = buttons_window.GetDuration(parsed_affect)
  if est_duration ~= nil then
    local converted = est_duration / 60 * 4
    local converted_str = tostring(converted)
    SetAffect(affect, converted_str, notify_changes)
  end
end

function RemoveAffect(affect)
  local parsed_affect = parseAffect(affect)
  buttons_window.RemoveAffect(parsed_affect, notify_changes)
  badaffects_window.RemoveAffect(parsed_affect, notify_changes)
end

function DisarmedBroadcast(weapon)
  BroadcastPlugin(1, "!!! YOU WERE DISARMED! RE-EQUIP " .. weapon:upper() .. " !!!")
end

function TimerTriggered()
  buttons_window.Draw()
  badaffects_window.Draw()
end

function parseAffect(affect)
  affect = affect:match("^%s*(.-)%s*$"):lower()

  if affect == "ice invocation" or affect == "force field" then
    affect = "shield"

  elseif affect == "ooze invocation" then
    affect = "stone skin"
  
  elseif affect == "steam invocation" or affect == "wind walk" then
    affect = "pass door"

  elseif affect == "magma invocation" or affect == "frostborne" then
    affect = "fireshield"
  
  elseif (affect == "guise of nature") then
    affect = "armor"
  
  elseif affect == "whirlwind" or affect =="lightning invocation" or affect == "zeal" then
    affect = "haste"
  
  elseif affect == "disrupt sight" or affect == "flare" or affect == "color spray" or affect == "smoke evocation" then
    affect = "blindness"
  
  elseif affect == "mesmerize" or affect == "earth evocation" then
    affect = "web"

  elseif affect == "air invocation" or affect == "float" then
    affect = "levitation"

  elseif affect == "irritation" then
    affect = "plague"
  end

  return affect
end

---------------
-- GMCP stuff
---------------

function handleGmcpAdd()
  local gmcp_value = getGmcpValue("char.affect_application_msg")
  if gmcp_value.target == "you" then
    SetAffect(gmcp_value.skill:lower(), tonumber(gmcp_value.duration or 0))
  end
end

function handleGmcpRemove()
  local gmcp_value = getGmcpValue("char.affect_application_msg")
  if gmcp_value.target == "you" then
    RemoveAffect(gmcp_value.skill:lower())
  end
end

function handleGmcpCharacterName()
  if GetTriggerInfo("first_prompt", 8) then
    EnableTrigger("first_prompt", false)
    local gmcp_value = getGmcpValue("char.base")
    SetCharacterName(gmcp_value.name)
  end
end

function getGmcpValue(field)
  local res, value = CallPlugin("f67c4339ed0591a5b010d05b", "gmcpval", field)
  local func = load("return " .. value)
  if func then return func()
  else return nil end
end

]]>

</script>

</muclient>
