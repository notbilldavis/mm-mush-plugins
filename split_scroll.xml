<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>

<plugin
  name="split_scroll"
  author="Oona"
  id="f453be8f0a2cd84fb3f9ff8a"
  language="Lua"
  purpose="show a splitter when scrolling to always display the last 25 lines"
  save_state="y"
  date_written="2025-06-01 12:00:00"
  requires="4.71"
  version="1.0"
>

<description trim="y">

<![CDATA[

Does what it says on the tin, when you scroll up in your output window you will
still see the latest 25 or so lines at the bottom so you can go look at stuff
with out needing to worry about new stuff happening without your knowledge.

Click the down arrow button to shoot back down.

Use "split config" to open a window to make some adjustments if things are weird.

The variable count is a magic number you probably need to play with if your split
section isn't going away even at the bottom of the screen. Make it a little higher
and try it out, adjusting as needed.

Make your font the same as what is in your MUSH configuration -> output settings.

Only really tested with my own layout so let me know if it acts weird for you.

Use "split update" to update from github.

]]>

</description>

</plugin>

<aliases>
  <alias match="^split[ ]+config(|ure)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>Configure()</send>
  </alias>

  <alias match="^split[ ]+update$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>checkForUpdates()</send>
  </alias>
</aliases>

<script>

<![CDATA[

local can_update, update_helper = pcall(require, "updatehelper")
local serializer_installed, serialization_helper = pcall(require, "serializationhelper")
local config_installed, config_window = pcall(require, "configuration_miniwindow")
local const_installed, consts = pcall(require, "consthelper")

if can_update and update_helper.version == nil then
  update_helper.Update({{ local_file = GetInfo(56):gsub("\\", "/") .. "lua/updatehelper.lua", remote_file = "https://raw.githubusercontent.com/notbilldavis/mm-mush-plugins/refs/heads/main/lua/updatehelper.lua"}})
  package.loaded["updatehelper"] = nil
  can_update, update_helper = pcall(require, "updatehelper")
end

if can_update then
  if not config_installed then config_installed, config_window = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/configuration_miniwindow.lua") end
  if not serializer_installed then serializer_installed, serialization_helper = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/serializationhelper.lua") end
  if not const_installed then const_installed, consts = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/consthelper.lua") end
end

local WIN = GetPluginID()
local FONT = WIN .. "_font"

local LINE_HEIGHT
local WINDOW_HEIGHT
local WINDOW_WIDTH

local CONFIG = nil

counter = 0
init = false

function OnPluginInstall() pluginStart() end
function OnPluginClose() pluginStop() end
function OnPluginDisable() pluginStop() end
function OnPluginDisconnect() pluginStop() end

function doOnHelp()
  ColourNote("silver", "black", world.GetPluginInfo(world.GetPluginID(), 3))
end

function pluginStart()
  if not serialization_helper or not config_installed or not const_installed then
    ColourNote("black", "red", GetPluginName() .. ": You do not have the required files in your lua directory. Expect issues.") 
  end

  loadConfig()
  DoAfterSpecial(1, "create()", sendto.script)
end

function pluginStop()
  config_window.Hide()
  if can_update and CONFIG.AUTOUPDATE then
    checkForUpdates()
  else
    Note("Auto-update for '" .. GetPluginName() .. "' is disabled. Enable it in the plugin configuration to receive updates.")
  end  
end

function loadConfig()
  local def_font, def_size = GetInfo(20) or "Lucida Console", GetInfo(213) or 10
  CONFIG = serialization_helper.GetSerializedVariable("splitscroll_config")  
  CONFIG.BORDER_COLOR = serialization_helper.GetValueOrDefault(CONFIG.BORDER_COLOR, ColourNameToRGB("silver"))
  CONFIG.BUTTON_X_DISTANCE = serialization_helper.GetValueOrDefault(CONFIG.BUTTON_X_DISTANCE, 250)
  CONFIG.BUTTON_Y_DISTANCE = serialization_helper.GetValueOrDefault(CONFIG.BUTTON_Y_DISTANCE, 100)
  CONFIG.BUTTON_HEIGHT = serialization_helper.GetValueOrDefault(CONFIG.BUTTON_HEIGHT, 50)
  CONFIG.BUTTON_WIDTH = serialization_helper.GetValueOrDefault(CONFIG.BUTTON_WIDTH, 50)
  CONFIG.BUTTON_COLOR = serialization_helper.GetValueOrDefault(CONFIG.BUTTON_COLOR, ColourNameToRGB("dimgray"))
  CONFIG.ARROW_COLOR = serialization_helper.GetValueOrDefault(CONFIG.ARROW_COLOR, ColourNameToRGB("darkgray"))
  CONFIG.SPLIT_FONT = serialization_helper.GetValueOrDefault(CONFIG.SPLIT_FONT, { name = def_font, size = def_size })
  CONFIG.ROW_COUNT = serialization_helper.GetValueOrDefault(CONFIG.ROW_COUNT, 15)
  CONFIG.VARIABLE_COUNT = serialization_helper.GetValueOrDefault(CONFIG.VARIABLE_COUNT, 800)
  CONFIG.WINDOW_LEFT = serialization_helper.GetValueOrDefault(CONFIG.WINDOW_LEFT, consts.GetOutputLeftOutside())
  CONFIG.WINDOW_RIGHT = serialization_helper.GetValueOrDefault(CONFIG.WINDOW_RIGHT, consts.GetOutputRightOutside())
  CONFIG.TEXT_OFFSET = serialization_helper.GetValueOrDefault(CONFIG.TEXT_OFFSET, 0)
end

function create()
  local font = CONFIG["SPLIT_FONT"]  
  WindowFont(WIN, FONT, font.name, font.size)
  
  LINE_HEIGHT = GetInfo(212)
  WINDOW_HEIGHT = LINE_HEIGHT * CONFIG.ROW_COUNT + consts.GetBorderWidth() * 2 + consts.GetBorderOffset() * 2
  WINDOW_WIDTH = CONFIG.WINDOW_RIGHT - CONFIG.WINDOW_LEFT

  local top = consts.GetOutputBottomOutside() - WINDOW_HEIGHT

  WindowCreate(WIN, CONFIG.WINDOW_LEFT, top, WINDOW_WIDTH, WINDOW_HEIGHT,
    miniwin.pos_center_all, miniwin.create_absolute_location, ColourNameToRGB("black"))
end

function OnPluginTick()
  drawSplitScroll()
end

function drawSplitScroll()
  if CONFIG == nil then return end

  counter = counter + 1
  if counter % 13 == 0 then
    counter = 0
    return
  end

  local scroll = GetInfo(296)
  local total_height = GetLinesInBufferCount() * GetInfo(212)

  if scroll < total_height - CONFIG.VARIABLE_COUNT then
    drawLines()

    WindowShow(WIN, true)
  else
    WindowShow(WIN, false)
  end
end

function drawLines()
  WindowRectOp(WIN, miniwin.rect_fill, 0, 0, 0, 0, ColourNameToRGB("black"))
  
  for i = 0, consts.GetBorderWidth() - 1 do
    WindowRectOp(WIN, miniwin.rect_frame, 0 + i, 0 + i, WINDOW_WIDTH - i, WINDOW_HEIGHT - i, CONFIG.BORDER_COLOR)
  end  
  
  WindowAddHotspot(WIN, "textarea", 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, "", "", "OnTextAreaMouseDown", "", "OnTextAreaMouseUp", "", miniwin.cursor_ibeam, 0)
  WindowDragHandler(WIN, "textarea", "OnTextAreaMouseMove", "", 0x10)
  WindowScrollwheelHandler(WIN, "textarea", "OnWheelScroll")
  
  local cnt = 0
  local lines_in_buffer = GetLinesInBufferCount()
  for line = lines_in_buffer - CONFIG.ROW_COUNT, lines_in_buffer do
    drawLine(line, cnt * LINE_HEIGHT + consts.GetBorderWidth() + consts.GetBorderOffset())
    cnt = cnt + 1
  end

  drawScrollToBottomButton()
end

function drawScrollToBottomButton()
  local btn_left = WINDOW_WIDTH - consts.GetBorderWidth() - CONFIG.BUTTON_X_DISTANCE
  local btn_top = WINDOW_HEIGHT - consts.GetBorderWidth() - CONFIG.BUTTON_Y_DISTANCE
  local btn_right = btn_left + CONFIG["BUTTON_WIDTH"]
  local btn_bottom = btn_top + CONFIG["BUTTON_HEIGHT"]

  WindowRectOp(WIN, miniwin.rect_fill, btn_left, btn_top, btn_right, btn_bottom, CONFIG.BUTTON_COLOR)

  local centerX = (btn_left + btn_right) / 2
  local point1 = { x = centerX, y = btn_bottom - 10 }
  local point2 = { x = btn_left + 10, y = btn_top + 10 }
  local point3 = { x = btn_right - 10, y = btn_top + 10 }

  local downArrow = string.format("%d,%d,%d,%d,%d,%d", point1.x, point1.y, point2.x, point2.y, point3.x, point3.y)

  WindowPolygon(WIN, downArrow, CONFIG.ARROW_COLOR, miniwin.pen_solid, 1, CONFIG.ARROW_COLOR, miniwin.brush_solid, true, false)
  WindowAddHotspot(WIN, "scroll_to_bottom", btn_left, btn_top, btn_right, btn_bottom, "", "", "OnScrollToBottom", "", "", "Scroll to bottom", miniwin.cursor_hand, 0)
end

function drawLine(i, y)
  local x = consts.GetBorderWidth() + consts.GetBorderOffset() + CONFIG.TEXT_OFFSET
  local style_count = GetLineInfo(i, 11)
  if style_count == nil then 
    WindowText(WIN, FONT, "there was a problem with line " .. i .. ", sorry", x, y, 0, 0, ColourNameToRGB("white"))
    return 
  end
  for s = 1, style_count do
    local fgcol = GetStyleInfo(i, s, 14)
    local bgcol = GetStyleInfo(i, s, 15) or ColourNameToRGB("black")
    local txt = GetStyleInfo(i, s, 1)
    local w = WindowTextWidth(WIN, FONT, txt)

    if bgcol then
      WindowRectOp(WIN, miniwin.rect_fill, x, y, x + w, y + LINE_HEIGHT, bgcol)
    end
    
    WindowText(WIN, FONT, txt, x, y, 0, 0, fgcol)
    x = x + w
  end
end

function OnTextAreaMouseUp(flags, hotspot_id)
  if flags == miniwin.hotspot_got_rh_mouse then
    local menu_items = "Scroll to Bottom | Configure"
    local result = WindowMenu(WIN, WindowInfo(WIN, 14),  WindowInfo(WIN, 15), menu_items)
    if result == "Scroll to Bottom" then OnScrollToBottom()
    elseif result == "Configure" then Configure()
    end
  end
end

function OnScrollToBottom()
  SetScroll(-1, true)
end

function OnWheelScroll(flags, hotspot_id)
  local newPos = GetInfo(296)
  
  if bit.band(flags, miniwin.wheel_scroll_back) ~= 0 then
    newPos = newPos + (LINE_HEIGHT * 3)
  else
    newPos = newPos - (LINE_HEIGHT * 3)
  end

  SetScroll(newPos, true)
end

function showWindow()
  WindowShow(WIN, true)
end

function hideWindow()
  WindowShow(WIN, false)
end

function Configure()
  if config_installed then
    local config = {
      _1_PANEL = {
        BORDER_COLOR = config_window.CreateColorOption(1, "Border", CONFIG.BORDER_COLOR, "The border color for the entire panel."),
        SPLIT_FONT = config_window.CreateFontOption(2, "Font", CONFIG.SPLIT_FONT, "The font used to display what is captured, should be the same as output."),
        ROW_COUNT = config_window.CreateNumberOption(3, "Row Count", CONFIG.ROW_COUNT, 1, 20, "Total number of rows to keep updated while you scroll."),
        VARIABLE_COUNT = config_window.CreateNumberOption(4, "Variable Count", CONFIG.VARIABLE_COUNT, 0, 2000, "A magic number you can fiddle with to fix when the split shows."),
      },
      _2_SCROLL_BUTTON = {
        BUTTON_X_DISTANCE = config_window.CreateNumberOption(1, "X-Offset", CONFIG.BUTTON_X_DISTANCE, 0, 1000, "The distance from the right edge of the panel."),
        BUTTON_Y_DISTANCE = config_window.CreateNumberOption(2, "Y-Offset", CONFIG.BUTTON_Y_DISTANCE, 0, 1000, "The distance from the bottom edge of the panel."),
        BUTTON_HEIGHT = config_window.CreateNumberOption(3, "Height", CONFIG.BUTTON_HEIGHT, 5, 250, "The height of the button."),
        BUTTON_WIDTH = config_window.CreateNumberOption(4, "Width", CONFIG.BUTTON_WIDTH, 5, 250, "The width of the button."),
        BUTTON_COLOR = config_window.CreateColorOption(5, "Background Color", CONFIG.BUTTON_COLOR, "The background color of the button."),
        ARROW_COLOR = config_window.CreateColorOption(6, "Foreground Color", CONFIG.ARROW_COLOR, "The foreground color of the button. Specifically the arrow.")
      },
      _3_POSITION = {
        WINDOW_LEFT = config_window.CreateNumberOption(1, "Left", CONFIG.WINDOW_LEFT, 0, CONFIG.WINDOW_RIGHT, "The left most position of the entire panel."),
        WINDOW_RIGHT = config_window.CreateNumberOption(2, "Right", CONFIG.WINDOW_RIGHT, CONFIG.WINDOW_LEFT, consts.GetClientWidth() - 250, "The right most position of the entire panel."),
        TEXT_OFFSET = config_window.CreateNumberOption(3, "Text Offset", CONFIG.TEXT_OFFSET, -10, 10, "Offset just the text left or right."),
      }
    }
    
    config_window.Show(config, onConfigureDone)
  else
    Note("Make sure you have the configuration_miniwindow.lua file in your lua folder and reinstall this plugin.")
  end
end

function onConfigureDone(group_id, option_id, config)
  CONFIG[option_id] = config.raw_value
  serialization_helper.SaveSerializedVariable("splitscroll_config", CONFIG)
  create()  
end

function ShowDebug()
  local buffer_count = GetLinesInBufferCount()
  Note("scroll: " .. GetInfo(296))
  Note("last line: " .. buffer_count)
  Note("height: " .. buffer_count * GetInfo(212))
  Note("top: " .. TOP)
  Note("left: " .. LEFT)
  Note("right: " .. RIGHT)
end

function checkForUpdates()
  if can_update then
    update_helper.Update(GetPluginInfo(GetPluginID(), 6):gsub("\\", "/"), "split_scroll.xml")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/configuration_miniwindow.lua")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/serializationhelper.lua")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/consthelper.lua")
  else
    ColourNote("red", "black", GetPluginName() .. ": UpdateHelper was not found. Make sure updatehelper.lua is in your lua folder.")
  end
end

]]>

</script>

</muclient>
