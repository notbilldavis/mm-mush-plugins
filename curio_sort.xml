<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>

<plugin
   name="curio_sort"
   author="Oona"
   id="c8b8a228de108e21e43b9baf"
   language="Lua"
   purpose="sort your curios by expiration"
   save_state="y"
   date_written="2025-05-02 12:00:00"
   requires="4.71"
   version="1.0">

<description trim="y">

<![CDATA[

Adds new commands to help with curio management.

 * curio sort
 * curio ignore <name>
 * curio offset <number>

Set the offset based on how many hours ahead or behind of system time you are.

Altars will be sorted by expiration with the ones closest to expiring at the bottom.
The expiration countdown will be yellow if there is less than 7 days left and will be
red if there are less than 3 days left.

Ignored altars wont be shown, useful for the RU and unknown altars.
Ignore again to remove it from the ignore list.

The location links will "run" or "mapper goto" where appropriate.

]]>

</description>

</plugin>

<aliases>
  <alias match="^curio sort(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>beginCurioSort("%1")</send>
  </alias>

  <alias match="^curio[ ]+offset[ ]+(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>setOffset("%1")</send>
  </alias>

  <alias match="^curio[ ]+ignore[ ]+(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>ignoreAltar("%1")</send>
  </alias>

  <alias match="^curio[ ]+setchar[ ]+(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>setCharacterName("%1")</send>
  </alias>

  <alias match="^curio[ ]+help$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>showCommands()</send>
  </alias>
</aliases>

<triggers>
  <trigger group="get_curios" keep_evaluating="n" regexp="y" send_to="12" sequence="100" omit_from_output="y" match="^(.*?) altar not active\.$">
    <send>addToAltar("%1", "[not active]", "")</send>
  </trigger>

  <trigger group="get_curios" keep_evaluating="y" regexp="y" send_to="12" sequence="101" omit_from_output="y" match="^(.*) (\d+) (.*)$">
    <send></send>
  </trigger>

  <trigger group="get_curios" keep_evaluating="y" regexp="y" send_to="12" sequence="101" omit_from_output="y" match="^Expires on (.*)$">
    <send></send>
  </trigger>

  <trigger group="get_curios" lines_to_match="2" keep_evaluating="n" multi_line="y" regexp="y" send_to="12" sequence="102" omit_from_output="n" match="^(.*) (\d+) (.*)\n(.*?)\n$">
    <send>addToAltar("%1", "%2 %3", "%4")</send>
  </trigger>  

  <trigger group="get_curios" keep_evaluating="n" regexp="y" send_to="14" sequence="100" omit_from_output="y" match="^Type \'HELP CURIO\' for more information\.$">
    <send>
      EnableTriggerGroup("get_curios", false)
      showSortedAltars()
    </send>
  </trigger>

  <trigger enabled="y" name="first_prompt" keep_evaluating="y" match="^(|[^ ]+(.*?))(\&lt;(.+)hp (.+)sp (.+)st\&gt;|\(.+\)) $" regexp="y" send_to="12" sequence="100">
    <send>onFirstPrompt()</send>
  </trigger>
</triggers>

<script>

<![CDATA[

require "gmcphelper"

altars = {}
ignore = {}

hour_offset = 1
show_all = true
character_name = nil

longest = {}

altar_locations = {
  ["Curious Altar"] = { zone = "run runeforest", zone_label = "[Rune Forest]", room = "mapper goto 946163", room_label = "[A Misty Path]" },
  ["Excited Altar"] = { zone = "mapper goto 15235", zone_label = "[Focault]", room = "", room_label = "[Focault]" },
  ["Jealous Altar"] = { zone = "run wroth", zone_label = "[Wroth]", room = "mapper goto 7920", room_label = "[Gateway Portal]" },
  ["Confused Altar"] = { zone = "run tavernoftheboars", zone_label = "[Tavern of the Boars]", room = "mapper goto 7998", room_label = "[A Dirt Path]" },
  ["Triumphant Altar"] = { zone = "run avarice", zone_label = "[Avarice]", room = "", room_label = "[Dracolich]" },
  ["Compassionate Altar"] = { zone = "run avarice", zone_label = "[Avarice]", room = "mapper goto 13957", room_label = "[Sacrifice]" },
  ["Loving Altar"] = { zone = "run twinmoons", zone_label = "[Twin Moons]", room = "mapper goto 154884", room_label = "[An Old Outhouse]" },
  ["Envious Altar"] = { zone = "run lonelydragon", zone_label = "[Lonely Dragon]", room = "mapper goto 155235", room_label = "[The Western Alcove]" },
  ["Nostalgic Altar"] = { zone = "", zone_label = "[Aequtus]", room = "mapper goto 195862", room_label = "[Cargo Hold]" },
  ["Joyful Altar"] = { zone = "run diocletian", zone_label = "[Diocletian]", room = "mapper goto 28952", room_label = "[Main Basilica Hallway]" },
  ["Fearful Altar"] = { zone = "run sigil", zone_label = "[Sigil]", room = "mapper goto 28042", room_label = "[The Inner Sanctum]" },
  ["Bored Altar"] = { zone = "run sigil", zone_label = "[Sigil]", room = "", room_label = "[Manticore]" },
  ["Ambitious Altar"] = { zone = "run vesuvius", zone_label = "[Vesuvius]", room = "", room_label = "[Vyst]" },
  ["Angry Altar"] = { zone = "run tellerium", zone_label = "[Tellerium]", room = "mapper goto 41205", room_label = "[Northwest Corner of Town Square]" },
  ["Hopeful Altar"] = { zone = "", zone_label = "[Ogre Village]", room = "mapper goto 167051", room_label = "[Bentnose]" },
  ["Suspicious Altar"] = { zone = "", zone_label = "[Begora's Sanctuary]", room = "mapper goto 96034", room_label = "[Sanctuary]" },
  ["Sad Altar"] = { zone = "", zone_label = "[Jalur Lumber Camp]", room = "mapper goto 336837", room_label = "[The Camp Square]" },
  ["Content Altar"] = { zone = "run pc", zone_label = "[Pirate's Cove]", room = "mapper goto 30301", room_label = "[Kraken's Throne Room]" },
  ["Serene Altar"] = { zone = "run deceit", zone_label = "[Deceit]", room = "", room_label = "[Yourban]" },
  ["Rebellious Altar"] = { zone = "", zone_label = "[Seelie]", room = "mapper goto 32503", room_label = "[The Spymaster's Armory]" },
  ["Proud Altar"] = { zone = "", zone_label = "[Seelie]", room = "mapper goto 32109", room_label = "[The King's Chamber]" },
  ["Regretful Altar"] = { zone = "", zone_label = "[Unseelie]", room = "mapper goto 33099", room_label = "[A High Throne]" },
  ["Peaceful Altar"] = { zone = "", zone_label = "[Rahdiyr]", room = "", room_label = "[Lathimus]" },
  ["Mischievous Altar"] = { zone = "run vir", zone_label = "[Vir]", room = "", room_label = "[Beyonder]" },
  ["Vengeful Altar"] = { zone = "run vir", zone_label = "[Vir]", room = "mapper goto 146915", room_label = "[Inside the Forge]" },
  ["Frustrated Altar"] = { zone = "run arienduth", zone_label = "[Arien'dyth]", room = "mapper goto 151274", room_label = "[East Side of the Gateguard's Tower]" },
  ["Overwhelmed Altar"] = { zone = "", zone_label = "[Swiveling Hooks]", room = "mapper goto 12336", room_label = "[A Sphereical Habitat]" },
  ["Determined Altar"] = { zone = "", zone_label = "[Sea Hag]", room = "mapper goto 152944", room_label = "[Musty Bedroom]" },
  ["Grateful Altar"] = { zone = "", zone_label = "[Hellbent]", room = "mapper goto 107297", room_label = "[Hidden Alcove]" },
  ["Lonely Altar"] = { zone = "run avarice", zone_label = "[Waylander's Retreat]", room = "mapper goto 33869", room_label = "[A Babbling Brook]" },
  ["Tranquil Altar"] = { zone = "", zone_label = "[Kalywak]", room = "mapper goto 153834", room_label = "[In The Coven Building Proper]" },
  ["Inspired Altar"] = { zone = "", zone_label = "[Future Anguish]", room = "mapper goto 24091", room_label = "[The Vivisection Chamber]" },
  ["Breathtaking Altar"] = { zone = "", zone_label = "[Van Pelt]", room = "mapper goto 253834", room_label = "[Emporium]" },
  ["Priceless Altar"] = { zone = "", zone_label = "[Van Pelt]", room = "mapper goto 353849", room_label = "[Tapestry-Lined Corridor]" },
  ["Chemically Altered Altar"] = { zone = "", zone_label = "[Unknown]", room = "", room_label = "[Unknown]" }
}

function OnPluginConnect()
  hour_offset = GetVariable("hour_offset") or 1
  EnableTriggerGroup("get_curios", false)
end

function OnPluginInstall()
  Note("-- " .. GetPluginInfo(GetPluginID(), 1) .. ": installed --")
  EnableTriggerGroup("get_curios", false)
end

function onFirstPrompt()
  EnableTrigger("first_prompt", false)
  Execute("sendgmcp char.base")
end

function OnPluginBroadcast(msg, id, pname, text)
  if id == "f67c4339ed0591a5b010d05b" then
    if (text == "char.base") then
      if character_name == nil or character_name == "" then
        local res, gmcparg = CallPlugin("f67c4339ed0591a5b010d05b", "gmcpval", "char.base")
        luastmt = "gmcpdata = " .. gmcparg
        assert(loadstring(luastmt or ""))()
        setCharacterName(gmcpval("name"))
      end
    end
  end
end

function setCharacterName(name)
  if name == nil or name == "" then
    Note("Unknown character name, set with 'curio setchar <name>'") 
  else
    character_name = name

    ignore = {}

    local ignore_text = GetVariable(character_name .. "_ignored_altars") or ""   
    if ignore_text == "" then
      ignore_text = GetVariable("ignored_altars") or ""
      if ignore_text ~= "" then
        ignore = deserialize(ignore_text)
        DeleteVariable("ignored_altars")
        SetVariable(character_name .. "_ignored_altars", serialize(ignore))
        SaveState()
      end
    else
      ignore = deserialize(ignore_text)
    end

    DoAfterSpecial(3, "showExpiringAltars()", sendto.script)
  end
end

function setOffset(offset)
  hour_offset = tonumber(offset)
  SetVariable("hour_offset", hour_offset)
  SaveState()
end

function beginCurioSort(ext)
    show_all = true
    if ext ~= nil and #ext > 2 and ext:sub(1, 3) == "exp" then 
      show_all = false 
    end

    EnableTriggerGroup("get_curios", true)
    altars = {}
    Send("curio")
end

function addToAltar(name, affect, expiration)
  local altar_name = getDisplayName(name)
  
  if altar_name ~= nil then
    local parsed_expiration = parseDate(expiration)
    if (parsed_expiration ~= nil) then
      parsed_expiration = parsed_expiration + (hour_offset * 3600)
    end

    local location = altar_locations[altar_name]
    local color, timer_string = getTimerColorAndString(parsed_expiration)

    if shouldShow(altar_name) and (show_all or color ~= "green") then
      longest.altar = getLongest(longest.altar, altar_name)
      longest.zone = getLongest(longest.zone, location.zone_label)
      longest.room = getLongest(longest.room, location.room_label)
      longest.affect = getLongest(longest.affect, affect, true)
      longest.expire = getLongest(longest.expire, timer_string)
    end

    table.insert(altars, { name = altar_name, affect = affect, expiration = parsed_expiration })
  end
end

function getLongest(current_max, string_to_check, debug)
  current_max = current_max or 0
  return math.max(current_max, #string_to_check)
end

function ignoreAltar(name)
  if character_name == nil or character_name == "" then
    Note("The plugin 'curio_sort' is not ready, try again in a few seconds.")
  else
    local lower_name = Trim(name:lower())
    if ignore[lower_name] then
      ignore[lower_name] = nil
      Tell("No longer ignoring ")
      ColourTell("white", "black", name)
      Tell(".")
      Note("")
    else
      ignore[lower_name] = true
      Tell("Now ignoring ")
      ColourTell("white", "black", name)
      Tell(".")
      Note("")
    end

    SetVariable(character_name .. "_ignored_altars", serialize(ignore))
    SaveState()
  end
end

function shouldShow(name)
  local lower_name = name:lower()
  return ignore[lower_name] ~= true
end

function getDisplayName(ogName)
  local name = ogName:match("^%s*(.-)%s*$")
  if (name == "Curious Altar:") then
    return "Curious Altar"
  elseif (name == "Excited Altar:") then    
    return "Excited Altar"    
  elseif (name == "Jealous Altar:") then    
    return "Jealous Altar"
  elseif (name == "Confused Altar:") then    
    return "Confused Altar"
  elseif (name == "Triumphant Alta") then    
    return "Triumphant Altar"
  elseif (name == "Compassionate A") then    
    return "Compassionate Altar"
  elseif (name == "Loving Altar:") then    
    return "Loving Altar"
  elseif (name == "Envious Altar:") then    
    return "Envious Altar"
  elseif (name == "Nostalgic Altar") then    
    return "Nostalgic Altar"
  elseif (name == "Joyful Altar:") then    
    return "Joyful Altar"
  elseif (name == "Fearful Altar:") then    
    return "Fearful Altar"
  elseif (name == "Bored Altar:") then    
    return "Bored Altar"
  elseif (name == "Ambitious Altar") then    
    return "Ambitious Altar"
  elseif (name == "Angry Altar:") then    
    return "Angry Altar"
  elseif (name == "Hopeful Altar:") then    
    return "Hopeful Altar"
  elseif (name == "Suspicious Altar") then    
    return "Suspicious Altar"
  elseif (name == "Sad Altar:") then    
    return "Sad Altar"
  elseif (name == "Content Altar:") then    
    return "Content Altar"
  elseif (name == "Serene Altar:") then    
    return "Serene Altar"
  elseif (name == "Rebellious Alta") then    
    return "Rebellious Altar"
  elseif (name == "Proud Altar:") then    
    return "Proud Altar"
  elseif (name == "Regretful Altar") then    
    return "Regretful Altar"
  elseif (name == "Peaceful Altar:") then
    return "Peaceful Altar"
  elseif (name == "Mischievous Alt") then
    return "Mischievous Altar"
  elseif (name == "Vengeful Altar:") then
    return "Vengeful Altar"
  elseif (name == "Frustrated Alta") then
    return "Frustrated Altar"
  elseif (name == "Overwhelmed Alt") then
    return "Overwhelmed Altar"
  elseif (name == "Determined Alta") then
    return "Determined Altar"
  elseif (name == "Grateful Altar:") then
    return "Grateful Altar"
  elseif (name == "Lonely Altar:") then
    return "Lonely Altar"
  elseif (name == "Tranquil Altar:") then
    return "Tranquil Altar"
  elseif (name == "Inspired Altar:") then
    return "Inspired Altar"
  elseif (name == "Breathtaking Al") then
    return "Breathtaking Altar"
  elseif (name == "Priceless Altar") then
    return "Priceless Altar"
  elseif (name == "Chemically Alte") then
    return "Chemically Altered Altar"
  end
  return nil
end

function showSortedAltars()
  table.sort(altars, function(a, b)
    if (a.expiration == nil) then return false end
    if (b.expiration == nil) then return true end
    return b.expiration < a.expiration 
  end)

  longest.altar = longest.altar + 2
  longest.affect = longest.affect + 2
  longest.zone = longest.zone + 2
  longest.room = longest.room + 2
  longest.expire = longest.expire + 2

  displayHeader()

  local total_count, expiring_count, expired_count, ignored_count = 0, 0, 0, 0
  for _, altar in ipairs(altars) do
    if altar.name ~= nil and altar.name ~= "" and altar_locations[altar.name] ~= nil then
      if (shouldShow(altar.name)) then
        total_count = total_count + 1

        local color, timer_string = getTimerColorAndString(altar.expiration)

        if show_all or color ~= "green" then
          Tell("|")      
          ColourTell("white", "black", " " .. altar.name .. string.rep(" ", longest.altar - #altar.name - 1))
          Tell("|")
          doLocation(altar.name)
          Tell("|")
          ColourTell("cyan", "black", " " .. altar.affect .. string.rep(" ", longest.affect - #altar.affect - 1))
          Tell("|")
          ColourTell(color, "black", " " .. timer_string .. string.rep(" ", longest.expire - #timer_string - 1))
          Note("|")

          if color == "red" then expired_count = expired_count + 1
          elseif color == "yellow" then expiring_count = expiring_count + 1 
          end
        end
      else
        ignored_count = ignored_count + 1
      end
    end
  end

  if not show_all then
    total_count = 0
    ignored_count = 0
  end

  displayFooter(total_count, ignored_count, expiring_count, expired_count)
end

function showExpiringAltars()
  show_all = false
  EnableTriggerGroup("get_curios", true)
  Send("curio")
end

function getTimerColorAndString(time)
  if (time == nil) then
    return "red", "This altar is not active, go get it."
  else
    local now = os.time()
    local diff = os.difftime(time, now)

    if diff < 0 then
      return "red", "EXPIRED"
    else
      local seconds = diff % 60
      local minutes = math.floor(diff / 60) % 60
      local hours = math.floor(diff / 3600) % 24
      local days = math.floor(diff / 86400)
  
      local color = "green"
      if (days < 3) then
        color = "red"
      elseif (days < 7) then
        color = "yellow"
      end

      local expiration = string.format("%d days, %02d hours, %02d minutes, %02d seconds", days, hours, minutes, seconds)

      return color, expiration
    end
  end
end

function doLocation(name)
  local zone = altar_locations[name]["zone"]
  local room = altar_locations[name]["room"]
  local zone_label = altar_locations[name]["zone_label"]
  local room_label = altar_locations[name]["room_label"]

  Tell(" ")

  if zone ~= nil and zone ~= "" then
    Hyperlink(zone, zone_label, zone, "silver", "black", false)
  else
    ColourTell("silver", "black", zone_label)
  end
  Tell(string.rep(" ", longest.zone - #zone_label - 1))
  Tell("| ")
  if room ~= nil and room ~= "" then
    Hyperlink(room, room_label, room, "silver", "black", false)
  else
    ColourTell("silver", "black", room_label)
  end
  Tell(string.rep(" ", longest.room - #room_label - 1))
end

function parseDate(str)
  if str == nil or str == "[not active]" or str == "" then
    return nil
  else
    str = str:gsub("^Expires on ", ""):gsub("%s+", " "):gsub("%.$", ""):gsub("^%s+", ""):gsub("%s+$", "")
    local success, result = pcall(function()
      local day_name, month_str, day, hour, min, sec, year = str:match("(%a+) (%a+) (%d+) (%d+):(%d+):(%d+) (%d+)")
    
      local months = {
        Jan=1, Feb=2, Mar=3, Apr=4, May=5, Jun=6,
        Jul=7, Aug=8, Sep=9, Oct=10, Nov=11, Dec=12
      }

      local month = months[month_str]

      if not (month and day and hour and min and sec and year) then
        Note("could not parse: " .. str)
        return nil
      end

      return os.time({
        year = tonumber(year),
        month = month,
        day = tonumber(day),
        hour = tonumber(hour),
        min = tonumber(min),
        sec = tonumber(sec)
      })
    end)

    if (success) then
      return result
    else
      Note("Error parsing: " .. str);
    end
  end
end

function displayHeader()
  local total_width = longest.altar + longest.zone + longest.room + longest.affect + longest.expire + 4
  Tell(".")
  Tell(string.rep("-", total_width))
  Note(".")

  Tell("|")
  Tell(centerString("Curio Altars by Expiration", total_width))
  Note("|")

  Tell(".")
  Tell(string.rep("-", longest.altar))
  Tell(".")
  Tell(string.rep("-", longest.zone))
  Tell(".")
  Tell(string.rep("-", longest.room))
  Tell(".")
  Tell(string.rep("-", longest.affect))
  Tell(".")
  Tell(string.rep("-", longest.expire))
  Note(".")

  Tell("|")
  Tell(centerString("Altar Name", longest.altar))
  Tell("|")
  Tell(centerString("Zone", longest.zone))
  Tell("|")
  Tell(centerString("Room", longest.room))
  Tell("|")
  Tell(centerString("Affect", longest.affect))
  Tell("|")
  Tell(centerString("Expires", longest.expire))
  Note("|")

  Tell(".")
  Tell(string.rep("-", longest.altar))
  Tell(".")
  Tell(string.rep("-", longest.zone))
  Tell(".")
  Tell(string.rep("-", longest.room))
  Tell(".")
  Tell(string.rep("-", longest.affect))
  Tell(".")
  Tell(string.rep("-", longest.expire))
  Note(".")
end

function displayFooter(total, ignored, expiring, expired)
  local total_width = longest.altar + longest.zone + longest.room + longest.affect + longest.expire + 4

  Tell(".")
  Tell(string.rep("-", longest.altar))
  Tell(".")
  Tell(string.rep("-", longest.zone))
  Tell(".")
  Tell(string.rep("-", longest.room))
  Tell(".")
  Tell(string.rep("-", longest.affect))
  Tell(".")
  Tell(string.rep("-", longest.expire))
  Note(".")

  local footer_text = {}
  if total > 0 then table.insert(footer_text, total .. " total altars") end
  if ignored > 0 then table.insert(footer_text, ignored .. " ignored") end
  if expiring > 0 then table.insert(footer_text, expiring .. " expiring") end
  if expired > 0 then table.insert(footer_text, expired .. " expired") end

  Tell("|")
  Tell(centerString(table.concat(footer_text, ", "), total_width))
  Note("|")

  Tell(".")
  Tell(string.rep("-", total_width))
  Note(".")
end

function centerString(str, total_length)
  if total_length == nil or total_length <= 0 then total_length = longest end
  local str_len = #str
  if total_length <= str_len then
    return str
  end

  local padding = total_length - str_len
  local left_padding = math.floor(padding / 2)
  local right_padding = padding - left_padding

  return string.rep(" ", left_padding) .. str .. string.rep(" ", right_padding)
end

function showCommands()
  showCommand("curio sort", "show your curio altars sorted by expiration date")
  showCommand("curio sort exp", "show only your expiring and expired altars")
  showCommand("curio ignore <altar>", "add or remove a specific altar from the sort output")
  showCommand("curio offset <hour>", "set the hour(s) off you are from the server time")
end

function showCommand(cmd, desc)
  Tell("* ")
  ColourTell("white", "black", cmd)
  Tell(" - ")
  ColourNote("silver", "black", desc)
end

function checkForUpdates()
  local updater_installed, updater = pcall(require, "updatehelper")

  if not updater_installed then
    ColourNote("red" , "black", "Could not find 'updatehelper.lua' while checking for updates.")
  else
    updater.Update({
      { local_file = GetPluginInfo(GetPluginID(), 6):gsub("\\", "/"), remote_file = "https://raw.githubusercontent.com/notbilldavis/mm-mush-plugins/refs/heads/main/profession_tracker.xml" },
    })
  end
end

function serialize(table)
  local function serializeValue(value)
    if type(value) == "table" then
      return serialize(value)
    elseif type(value) == "string" then
      return string.format("%q", value)
    else
      return tostring(value)
    end
  end

  local result = "{"
  for k, v in pairs(table) do
    local key
    if type(k) == "string" and k:match("^%a[%w_]*$") then
      key = k
    else
      key = "[" .. serializeValue(k) .. "]"
    end
    result = result .. key .. "=" .. serializeValue(v) .. ","
  end
  result = result .. "}"
  return result
end

function deserialize(serializedTable)
  local func = load("return " .. serializedTable)
  if func then
    return func()
  else
    return nil, "Failed to load string"
  end
end

]]>

</script>

</muclient>
