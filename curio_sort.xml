<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>

<plugin
   name="curio_sort"
   author="Oona"
   id="c8b8a228de108e21e43b9baf"
   language="Lua"
   purpose="sort your curios by expiration"
   save_state="y"
   date_written="2025-05-02 12:00:00"
   requires="4.71"
   version="1.0">

<description trim="y">

<![CDATA[

Adds new commands to help with curio management.

 * curio sort
 * curio ignore <name>
 * curio offset <number>

Set the offset based on how many hours ahead or behind of system time you are.

Altars will be sorted by expiration with the ones closest to expiring at the bottom.
The expiration countdown will be yellow if there is less than 7 days left and will be
red if there are less than 3 days left.

Ignored altars wont be shown, useful for the RU and unknown altars.
Ignore again to remove it from the ignore list.

The location links will "run" or "mapper goto" where appropriate.

]]>

</description>

</plugin>

<aliases>
  <alias match="^curio sort(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>beginCurioSort("%1")</send>
  </alias>

  <alias match="^curio[ ]+offset[ ]+(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>setOffset("%1")</send>
  </alias>

  <alias match="^curio[ ]+ignore[ ]+(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>ignoreAltar("%1")</send>
  </alias>

  <alias match="^curio[ ]+setchar[ ]+(.*?)$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>SetCharacterName("%1")</send>
  </alias>

  <alias match="^curio[ ]+help$" enabled="y" regexp="y" send_to="12" sequence="100">
    <send>showCommands()</send>
  </alias>
</aliases>

<triggers>
  <trigger group="get_curios" keep_evaluating="n" regexp="y" send_to="12" sequence="100" omit_from_output="y" match="^(.*?) altar not active\.$">
    <send>addToAltar("%1", "- not active", "")</send>
  </trigger>

  <trigger group="get_curios" keep_evaluating="y" regexp="y" send_to="12" sequence="101" omit_from_output="y" match="^(.*) (\d+) (.*)$">
    <send></send>
  </trigger>

  <trigger group="get_curios" keep_evaluating="y" regexp="y" send_to="12" sequence="101" omit_from_output="y" match="^Expires on (.*)$">
    <send></send>
  </trigger>

  <trigger group="get_curios" lines_to_match="2" keep_evaluating="n" multi_line="y" regexp="y" send_to="12" sequence="102" omit_from_output="n" match="^(.*) (\d+) (.*)\n(.*?)\n$">
    <send>addToAltar("%1", "%2 %3", "%4")</send>
  </trigger>  

  <trigger group="get_curios" keep_evaluating="n" regexp="y" send_to="14" sequence="100" omit_from_output="y" match="^Type \'HELP CURIO\' for more information\.$">
    <send>showSortedAltars()</send>
  </trigger>

  <trigger enabled="y" name="first_prompt" keep_evaluating="y" match="^(|[^ ]+(.*?))(\&lt;(.+)hp (.+)sp (.+)st\&gt;|\(.+\)) $" regexp="y" send_to="12" sequence="100">
    <send>OnFirstPrompt()</send>
  </trigger>
</triggers>

<script>

<![CDATA[

local can_update, update_helper = pcall(require, "updatehelper")
local const_installed, consts = pcall(require, "consthelper")
local serializer_installed, serialization_helper = pcall(require, "serializationhelper")

if can_update and update_helper.version == nil then
  update_helper.Update({{ local_file = GetInfo(56):gsub("\\", "/") .. "lua/updatehelper.lua", remote_file = "https://raw.githubusercontent.com/notbilldavis/mm-mush-plugins/refs/heads/main/lua/updatehelper.lua"}})
  package.loaded["updatehelper"] = nil
  can_update, update_helper = pcall(require, "updatehelper")
end

if can_update then
  if not const_installed then const_installed, consts = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/consthelper.lua") end
  if not serializer_installed then serializer_installed, serialization_helper = update_helper.UpdateAndRequire(GetInfo(56):gsub("\\", "/"), "lua/serializationhelper.lua") end
end

require "gmcphelper"

local saved_data = nil
local altars = {}
local longest = {}
local hour_offset = nil
local show_all = true
local sort_by = "expiration"
local sort_desc = true
local character_name = nil

altar_locations = {
  ["Curious Altar"] = { zone = "run runeforest", zone_label = "Rune Forest", room = "mapper goto 946163", room_label = "A Misty Path", },
  ["Excited Altar"] = { zone = "mapper goto 15235", zone_label = "Focault", room = "", room_label = "Focault", },
  ["Jealous Altar"] = { zone = "run wroth", zone_label = "Wroth", room = "mapper goto 7920", room_label = "Gateway Portal", },
  ["Confused Altar"] = { zone = "run tavernoftheboars", zone_label = "Tavern of the Boars", room = "mapper goto 7998", room_label = "A Dirt Path", },
  ["Triumphant Altar"] = { zone = "run avarice", zone_label = "Avarice", room = "", room_label = "Dracolich", },
  ["Compassionate Altar"] = { zone = "run avarice", zone_label = "Avarice", room = "mapper goto 13957", room_label = "Sacrifice", },
  ["Loving Altar"] = { zone = "run twinmoons", zone_label = "Twin Moons", room = "mapper goto 154884", room_label = "An Old Outhouse", },
  ["Envious Altar"] = { zone = "run lonelydragon", zone_label = "Lonely Dragon", room = "mapper goto 155235", room_label = "The Western Alcove", },
  ["Nostalgic Altar"] = { zone = "", zone_label = "Aequtus", room = "mapper goto 195862", room_label = "Cargo Hold", },
  ["Joyful Altar"] = { zone = "run diocletian", zone_label = "Diocletian", room = "mapper goto 28952", room_label = "Main Basilica Hallway", },
  ["Fearful Altar"] = { zone = "run sigil", zone_label = "Sigil", room = "mapper goto 28042", room_label = "The Inner Sanctum", },
  ["Bored Altar"] = { zone = "run sigil", zone_label = "Sigil", room = "", room_label = "Manticore", },
  ["Ambitious Altar"] = { zone = "run vesuvius", zone_label = "Vesuvius", room = "", room_label = "Vyst", },
  ["Angry Altar"] = { zone = "run tellerium", zone_label = "Tellerium", room = "mapper goto 41205", room_label = "Northwest Corner of Town Square", },
  ["Hopeful Altar"] = { zone = "", zone_label = "Ogre Village", room = "mapper goto 167051", room_label = "Bentnose", },
  ["Suspicious Altar"] = { zone = "", zone_label = "Begora's Sanctuary", room = "mapper goto 96034", room_label = "Sanctuary", },
  ["Sad Altar"] = { zone = "", zone_label = "Jalur Lumber Camp", room = "mapper goto 336837", room_label = "The Camp Square", },
  ["Content Altar"] = { zone = "run pc", zone_label = "Pirate's Cove", room = "mapper goto 30301", room_label = "Kraken's Throne Room", },
  ["Serene Altar"] = { zone = "run deceit", zone_label = "Deceit", room = "", room_label = "Yourban", },
  ["Rebellious Altar"] = { zone = "", zone_label = "Seelie", room = "mapper goto 32503", room_label = "The Spymaster's Armory", },
  ["Proud Altar"] = { zone = "", zone_label = "Seelie", room = "mapper goto 32109", room_label = "The King's Chamber", },
  ["Regretful Altar"] = { zone = "", zone_label = "Unseelie", room = "mapper goto 33099", room_label = "A High Throne", },
  ["Peaceful Altar"] = { zone = "", zone_label = "Rahdiyr", room = "", room_label = "Lathimus", },
  ["Mischievous Altar"] = { zone = "run vir", zone_label = "Vir", room = "", room_label = "Beyonder", },
  ["Vengeful Altar"] = { zone = "run vir", zone_label = "Vir", room = "mapper goto 146915", room_label = "Inside the Forge", },
  ["Frustrated Altar"] = { zone = "run arienduth", zone_label = "Arien'dyth", room = "mapper goto 151274", room_label = "East Side of the Gateguard's Tower", },
  ["Overwhelmed Altar"] = { zone = "", zone_label = "Swiveling Hooks", room = "mapper goto 12336", room_label = "A Sphereical Habitat", },
  ["Determined Altar"] = { zone = "", zone_label = "Sea Hag", room = "mapper goto 152944", room_label = "Musty Bedroom", },
  ["Grateful Altar"] = { zone = "", zone_label = "Hellbent", room = "mapper goto 107297", room_label = "Hidden Alcove", },
  ["Lonely Altar"] = { zone = "run avarice", zone_label = "Waylander's Retreat", room = "mapper goto 33869", room_label = "A Babbling Brook", },
  ["Tranquil Altar"] = { zone = "", zone_label = "Kalywak", room = "mapper goto 153834", room_label = "In The Coven Building Proper", },
  ["Inspired Altar"] = { zone = "", zone_label = "Future Anguish", room = "mapper goto 24091", room_label = "The Vivisection Chamber", },
  ["Breathtaking Altar"] = { zone = "", zone_label = "Van Pelt", room = "mapper goto 253834", room_label = "Emporium", },
  ["Priceless Altar"] = { zone = "", zone_label = "Van Pelt", room = "mapper goto 353849", room_label = "Tapestry-Lined Corridor", },
  ["Chemically Altered Altar"] = { zone = "", zone_label = "Unknown", room = "", room_label = "Unknown", }
}

function OnPluginInstall() pluginStart() end
function OnPluginEnable() pluginStart() end
function OnPluginConnect() pluginStart() end
function OnPluginClose() pluginStop() end
function OnPluginDisable() pluginStop() end
function OnPluginDisconnect() pluginStop() end

function OnPluginBroadcast(msg, id, pname, text)
  if id == "f67c4339ed0591a5b010d05b" then
    if (text == "char.base") then
      handleGmcpCharacterName()
    end
  end
end

function handleGmcpCharacterName()
  if GetTriggerInfo("first_prompt", 8) then
    EnableTrigger("first_prompt", false)
    local gmcp_value = serialization_helper.GetGmcpValue("char.base")
    SetCharacterName(gmcp_value.name)    
  end
end

function pluginStart()
  if not const_installed or not serializer_installed then 
    ColourNote("black", "red", GetPluginName() .. ": You do not have the required files in your lua directory. Expect issues.") 
  end

  longest.altar = 8
  longest.zone = 8
  longest.room = 8
  longest.affect = 10
  longest.expire = 10
  
  EnableTrigger("first_prompt", true)
  EnableTriggerGroup("get_curios", false)
end

function pluginStop()
  if can_update and IsAutoUpdateEnabled() then
    CheckForUpdates()
  else
    Note("Auto-update for '" .. GetPluginName() .. "' is disabled. Enable it in the plugin configuration to receive updates.")
  end
end

function IsAutoUpdateEnabled()
  return false -- todo
end

function OnFirstPrompt()
  Execute("sendgmcp char.base")
  DoAfterSpecial(2, "tryGetOffset()", sendto.script)
end

function tryGetOffset()
  hour_offset = consts.getHourOffset()
  if hour_offset == nil then
    EnableTrigger("capture_time_offset", true)
    Note("Sending time to get hour offset from server...")
    Send("time")
  else
    EnableTrigger("capture_time_offset", false)
  end    
end

function SetCharacterName(name)
  if name == nil or name == "" then
    Note("Unknown character name, set with 'curio setchar <name>'") 
  else
    character_name = name

    loadData()

    DoAfterSpecial(3, "showExpiringAltars()", sendto.script)
  end
end

function loadData()
  saved_data = serialization_helper.GetSerializedVariable(character_name .. "_curiosort_data")
  saved_data.ignore = serialization_helper.GetValueOrDefault(saved_data.ignore, { ["chemically altered altar"] = true })
  saved_data.affects = serialization_helper.GetValueOrDefault(saved_data.affects, {})
  saved_data.column_options = serialization_helper.GetValueOrDefault(saved_data.column_options, {})
  saved_data.column_options.altar = serialization_helper.GetValueOrDefault(saved_data.column_options.altar, "show")
  saved_data.column_options.zone = serialization_helper.GetValueOrDefault(saved_data.column_options.zone, "show")
  saved_data.column_options.room = serialization_helper.GetValueOrDefault(saved_data.column_options.room, "show")
  saved_data.column_options.affect = serialization_helper.GetValueOrDefault(saved_data.column_options.affect, "show")
  saved_data.column_options.expire = serialization_helper.GetValueOrDefault(saved_data.column_options.expire, "show")
end

function saveData()
  if character_name ~= nil then
    serialization_helper.SaveSerializedVariable(character_name .. "_curiosort_data", saved_data)
  end
end

function setOffset(offset)
  Note("Changing hour offset from " .. (hour_offset or "unset") .. " to " .. (offset or "unset") .. ".")
  hour_offset = tonumber(offset)
  SetVariable("hour_offset", hour_offset)
  SaveState()  
end

function beginCurioSort(args)
  if saved_data == nil then
    Note("The plugin 'curio_sort' is not ready, try again in a few seconds.")
    return
  end

  parseSortArgs(args)

  longest.altar = 8
  longest.zone = 8
  longest.room = 8
  longest.affect = 10
  longest.expire = 10

  EnableTriggerGroup("get_curios", true)
  altars = {}
  Send("curio")
end

function parseSortArgs(args)
  args = Trim(args:lower())
  show_all = true
  if args == "filter" then 
    show_all = false 
  elseif args ~= "" then
    local col_map = { altar = "name", zone = "zone", room = "room", affect = "affect", expire = "expiration" }
    local valid_cols = { altar = true, zone = true, room = true, affect = true, expire = true }
    local valid_opts = { show = true, shorten = true, collapse = true, hide = true}
    local col, opt = args:match("([^%s]+)%s*(.*)")
    if col ~= nil then
      col = Trim(col)
      if not valid_cols[col] then
        Note("Invalid column '" .. col .. "' provided.")
      else
        if opt == nil or Trim(opt) == "" then
          if sort_by == col_map[col] then
            sort_desc = not sort_desc
          else
            sort_by = col_map[col]
            sort_desc = true
          end
        else
          opt = Trim(opt)
          if not valid_opts[opt] then
            Note("Invalid option '" .. opt .. "' provided.")
          else
            saved_data.column_options[col] = opt
          end
        end
      end
    end
  end
end

function addToAltar(name, affect, expiration)
  local altar_name = getDisplayName(name)
  
  if altar_name ~= nil then
    local parsed_expiration = parseDate(expiration)
    if (parsed_expiration ~= nil) then
      parsed_expiration = parsed_expiration + (hour_offset * 3600)
    end

    local summon = affect:match("1 increased uses to (.+)")
    if summon ~= nil and #summon > 0 then affect = "1 " .. Trim(summon) end

    if affect ~= "- not active" then
      saved_data.affects[name] = affect
    elseif saved_data.affects[name] ~= nil then
      affect = saved_data.affects[name]
    end

    calculateLongest(altar_name, affect, parsed_expiration)

    table.insert(altars, { name = altar_name, affect = affect, expiration = parsed_expiration })
  end
end

function calculateLongest(altar_name, affect, parsed_expiration)
  local color, timer_string = getTimerColorAndString(parsed_expiration, saved_data.column_options.expire)
  
  if shouldShow(altar_name) and (show_all or color ~= "green") then
    local location = altar_locations[altar_name]

    local adjusted_altar_name = getAdjustedAltarName(altar_name, saved_data.column_options.altar or "show")
    local adjusted_zone_name = getAdjustedZoneName(location, saved_data.column_options.zone or "show")
    local adjusted_room_name = getAdjustedRoomName(location, saved_data.column_options.room or "show")
    local adjusted_affect_name = getAdjustedAffectName(affect, saved_data.column_options.affect or "show")
    
    longest.altar = math.max(longest.altar, #adjusted_altar_name)
    longest.zone = math.max(longest.zone, #adjusted_zone_name)
    longest.room = math.max(longest.room, #adjusted_room_name)
    longest.affect = math.max(longest.affect, #adjusted_affect_name)
    longest.expire = math.max(longest.expire, #timer_string)
  end
end

function getAdjustedAltarName(name, opt)
  if opt == "shorten" then
    return name:match("(.+) Altar")
  elseif opt == "collapse" then
    return name:sub(1, math.min(#name, 5))
  elseif opt == "hide" then
    return ""
  else
    return name
  end
end

function getAdjustedZoneName(location, opt)
  if opt == "shorten" then
    return location.zone_label:sub(1, math.min(#location.zone_label, 10))
  elseif opt == "collapse" then
    return location.zone_label:sub(1, math.min(#location.zone_label, 5))
  elseif opt == "hide" then
    return ""
  else
    return location.zone_label
  end
end

function getAdjustedRoomName(location, opt)
  if opt == "shorten" then
    local room = Trim(location.room:match("%d+") or "")
    if room == "" then
      room = location.room_label:sub(1, math.min(#location.room_label, 10))
    end
    return room
  elseif opt == "collapse" then
    local room = Trim(location.room:match("%d+") or "")
    if room == "" then
      room = location.room_label
    end
    return room:sub(1, math.min(#room, 5))    
  elseif opt == "hide" then
    return ""
  else
    return location.room_label
  end
end

function getAdjustedAffectName(affect, opt)
  if opt == "shorten" then
    return affect:sub(1, math.min(#affect, 10)) or "-"
  elseif opt == "collapse" then
    return affect:match("%d+") or "-"
  elseif opt == "hide" then
    return ""
  else
    return affect
  end
end

function ignoreAltar(name)
  if saved_data == nil then
    Note("The plugin 'curio_sort' is not ready, try again in a few seconds.")
  else
    local lower_name = Trim(name:lower())
    saved_data.ignore[lower_name] = not saved_data.ignore[lower_name]
    Tell((saved_data.ignore[lower_name] and "Now" or "No longer") .. " ignoring ")
    ColourTell("white", "black", name)
    Note(".")
    saveData()
  end
end

function shouldShow(name)
  local lower_name = name:lower()
  return saved_data.ignore[lower_name] ~= true
end

function getDisplayName(ogName)
  local name = ogName:match("^%s*(.-)%s*$")
  if (name == "Curious Altar:") then
    return "Curious Altar"
  elseif (name == "Excited Altar:") then    
    return "Excited Altar"    
  elseif (name == "Jealous Altar:") then    
    return "Jealous Altar"
  elseif (name == "Confused Altar:") then    
    return "Confused Altar"
  elseif (name == "Triumphant Alta") then    
    return "Triumphant Altar"
  elseif (name == "Compassionate A") then    
    return "Compassionate Altar"
  elseif (name == "Loving Altar:") then    
    return "Loving Altar"
  elseif (name == "Envious Altar:") then    
    return "Envious Altar"
  elseif (name == "Nostalgic Altar") then    
    return "Nostalgic Altar"
  elseif (name == "Joyful Altar:") then    
    return "Joyful Altar"
  elseif (name == "Fearful Altar:") then    
    return "Fearful Altar"
  elseif (name == "Bored Altar:") then    
    return "Bored Altar"
  elseif (name == "Ambitious Altar") then    
    return "Ambitious Altar"
  elseif (name == "Angry Altar:") then    
    return "Angry Altar"
  elseif (name == "Hopeful Altar:") then    
    return "Hopeful Altar"
  elseif (name == "Suspicious Altar") then    
    return "Suspicious Altar"
  elseif (name == "Sad Altar:") then    
    return "Sad Altar"
  elseif (name == "Content Altar:") then    
    return "Content Altar"
  elseif (name == "Serene Altar:") then    
    return "Serene Altar"
  elseif (name == "Rebellious Alta") then    
    return "Rebellious Altar"
  elseif (name == "Proud Altar:") then    
    return "Proud Altar"
  elseif (name == "Regretful Altar") then    
    return "Regretful Altar"
  elseif (name == "Peaceful Altar:") then
    return "Peaceful Altar"
  elseif (name == "Mischievous Alt") then
    return "Mischievous Altar"
  elseif (name == "Vengeful Altar:") then
    return "Vengeful Altar"
  elseif (name == "Frustrated Alta") then
    return "Frustrated Altar"
  elseif (name == "Overwhelmed Alt") then
    return "Overwhelmed Altar"
  elseif (name == "Determined Alta") then
    return "Determined Altar"
  elseif (name == "Grateful Altar:") then
    return "Grateful Altar"
  elseif (name == "Lonely Altar:") then
    return "Lonely Altar"
  elseif (name == "Tranquil Altar:") then
    return "Tranquil Altar"
  elseif (name == "Inspired Altar:") then
    return "Inspired Altar"
  elseif (name == "Breathtaking Al") then
    return "Breathtaking Altar"
  elseif (name == "Priceless Altar") then
    return "Priceless Altar"
  elseif (name == "Chemically Alte") then
    return "Chemically Altered Altar"
  end
  return nil
end

function showSortedAltars()
  EnableTriggerGroup("get_curios", false)

  table.sort(altars, function(a, b)
    if (a[sort_by] == nil) then return false end
    if (b[sort_by] == nil) then return true end
    if sort_desc then
      return b[sort_by] < a[sort_by]
    else
      return b[sort_by] > a[sort_by]
    end
  end)

  longest.altar = getColumnWidth("altar")
  longest.zone = getColumnWidth("zone")
  longest.room = getColumnWidth("room")
  longest.affect = getColumnWidth("affect")
  longest.expire = getColumnWidth("expire")

  displayHeader()

  local total_count, expiring_count, expired_count, ignored_count = 0, 0, 0, 0
  for _, altar in ipairs(altars) do
    if altar.name ~= nil and altar.name ~= "" and altar_locations[altar.name] ~= nil then
      if (shouldShow(altar.name)) then
        total_count = total_count + 1

        local color, timer_string = getTimerColorAndString(altar.expiration, saved_data.column_options.expire or "show")
        local adjusted_altar_name = getAdjustedAltarName(altar.name, saved_data.column_options.altar or "show")
        local adjusted_affect_name = getAdjustedAffectName(altar.affect, saved_data.column_options.affect or "show")

        if show_all or color ~= "green" then
          Tell("|")
          if saved_data.column_options.altar ~= "hide" then
            ColourTell("white", "black", " " .. adjusted_altar_name .. string.rep(" ", longest.altar - #adjusted_altar_name - 1))
            Tell("|")
          end

          doLocation(altar.name)
          
          if saved_data.column_options.affect ~= "hide" then
            if saved_data.column_options.affect == "collapse" then
              ColourTell("cyan", "black", centerString(adjusted_affect_name, longest.affect))
            else
              ColourTell("cyan", "black", " " .. adjusted_affect_name .. string.rep(" ", longest.affect - #adjusted_affect_name - 1))
            end
            Tell("|")
          end
          if saved_data.column_options.expire ~= "hide" then
            ColourTell(color, "black", " " .. timer_string .. string.rep(" ", longest.expire - #timer_string - 1))
            Note("|")
          end

          if color == "red" then expired_count = expired_count + 1
          elseif color == "yellow" or color == "orange" then expiring_count = expiring_count + 1 
          end
        end
      else
        ignored_count = ignored_count + 1
      end
    end
  end

  if not show_all then
    total_count = 0
    ignored_count = 0
  end

  displayFooter(total_count, ignored_count, expiring_count, expired_count)

  saveData()
end

function getColumnWidth(col)
  if saved_data.column_options[col] == "hide" then
    return 0
  elseif saved_data.column_options[col] == "collapse" then
    return 7
  else
    return longest[col] + 2 
  end
end

function showExpiringAltars()
  show_all = false
  EnableTriggerGroup("get_curios", true)
  Send("curio")
end

function getTimerColorAndString(time, opt)
  if (time == nil) then
    if opt == "shorten" then
      return "red", "not active"
    elseif opt == "collapse" then
      return "red", ""
    else
      return "red", "This altar is not active, go get it."
    end
  else
    local now = os.time()
    local diff = os.difftime(time, now)

    if diff < 0 then
      return "red", "EXPIRED"
    else
      local seconds = diff % 60
      local minutes = math.floor(diff / 60) % 60
      local hours = math.floor(diff / 3600) % 24
      local days = math.floor(diff / 86400)
  
      local color = "green"
      if (days < 3) then
        color = "orange"
      elseif (days < 7) then
        color = "yellow"
      end

      local expiration
      if opt == "shorten" then
        expiration = string.format("%02dd %02dh %02dm", days, hours, minutes)
      elseif opt == "collapse" then
        expiration = ""
      else
        expiration = string.format("%02d days, %02d hours, %02d minutes, %02d seconds", days, hours, minutes, seconds)
      end

      return color, expiration
    end
  end
end

function doLocation(name)
  local zone = altar_locations[name]["zone"]
  local room = altar_locations[name]["room"]
  
  local adjusted_zone_name = getAdjustedZoneName(altar_locations[name], saved_data.column_options.zone or "show")
  local adjusted_room_name = getAdjustedRoomName(altar_locations[name], saved_data.column_options.room or "show")

  if saved_data.column_options.zone ~= "hide" then
    Tell(" ")
    if zone ~= nil and zone ~= "" then
      Hyperlink(zone, adjusted_zone_name, zone, "silver", "black", false)
    else
      ColourTell("silver", "black", adjusted_zone_name)
    end
    Tell(string.rep(" ", longest.zone - #adjusted_zone_name - 1))
    Tell("|")
  end

  if saved_data.column_options.room ~= "hide" then
    Tell(" ")
    if room ~= nil and room ~= "" then
      Hyperlink(room, adjusted_room_name, room, "silver", "black", false)
    else
      ColourTell("silver", "black", adjusted_room_name)
    end
    Tell(string.rep(" ", longest.room - #adjusted_room_name - 1))
    Tell("|")
  end
end

function parseDate(str)
  if str == nil or str == "not active" or str == "" then
    return nil
  else
    str = str:gsub("^Expires on ", ""):gsub("%s+", " "):gsub("%.$", ""):gsub("^%s+", ""):gsub("%s+$", "")
    local success, result = pcall(function()
      local day_name, month_str, day, hour, min, sec, year = str:match("(%a+) (%a+) (%d+) (%d+):(%d+):(%d+) (%d+)")
    
      local months = {
        Jan=1, Feb=2, Mar=3, Apr=4, May=5, Jun=6,
        Jul=7, Aug=8, Sep=9, Oct=10, Nov=11, Dec=12
      }

      local month = months[month_str]

      if not (month and day and hour and min and sec and year) then
        Note("could not parse: " .. str)
        return nil
      end

      return os.time({
        year = tonumber(year),
        month = month,
        day = tonumber(day),
        hour = tonumber(hour),
        min = tonumber(min),
        sec = tonumber(sec)
      })
    end)

    if (success) then
      return result
    else
      Note("Error parsing: " .. str);
    end
  end
end

function displayHeader()
  local total_width = 4 + longest.altar + longest.zone + longest.room + longest.affect + longest.expire
  
  Tell(".")
  Tell(string.rep("-", total_width))
  Note(".")

  Tell("|")
  local title_bar = centerString("Curio Altars by " .. (sort_by:gsub("^%l", string.upper)) .. " (" .. (sort_desc and "desc" or "asc") .. ")", total_width)
  Tell(title_bar:sub(1, #title_bar - 2))
  Hyperlink("!!" .. GetPluginID() .. ":showCommands()", "?", "Show Commands", "silver", "black", false)
  Note(" |")

  Tell(".")
  if saved_data.column_options.altar ~= "hide" then
    Tell(string.rep("-", longest.altar))
    Tell(".")
  end
  if saved_data.column_options.zone ~= "hide" then
    Tell(string.rep("-", longest.zone))
    Tell(".")
  end
  if saved_data.column_options.room ~= "hide" then
    Tell(string.rep("-", longest.room))
    Tell(".")
  end
  if saved_data.column_options.affect ~= "hide" then
    Tell(string.rep("-", longest.affect))
    Tell(".")
  end
  if saved_data.column_options.expire ~= "hide" then
    Tell(string.rep("-", longest.expire))
    Note(".")
  end

  Tell("|")
  displayClickableHeader("Name", "altar")
  displayClickableHeader("Zone", "zone")
  displayClickableHeader("Room", "room")
  displayClickableHeader("Affect", "affect")
  displayClickableHeader("Expires", "expire")
  Note("")

  Tell(".")
  if saved_data.column_options.altar ~= "hide" then
    Tell(string.rep("-", longest.altar))
    Tell(".")
  end
  if saved_data.column_options.zone ~= "hide" then
    Tell(string.rep("-", longest.zone))
    Tell(".")
  end
  if saved_data.column_options.room ~= "hide" then
    Tell(string.rep("-", longest.room))
    Tell(".")
  end
  if saved_data.column_options.affect ~= "hide" then
    Tell(string.rep("-", longest.affect))
    Tell(".")
  end
  if saved_data.column_options.expire ~= "hide" then
    Tell(string.rep("-", longest.expire))
    Note(".")
  end
end

function displayClickableHeader(title, column)
  if saved_data.column_options[column] ~= "hide" then
    if saved_data.column_options[column] == "collapse" then
      title = title:sub(1, 1)
    end
    local s1, t, s2 = centerString(title, longest[column]):match("(%s*)(%S+)(%s*)")
    if #s1 > 2 then
      Tell(s1:sub(1, #s1 - 2))
      if saved_data.column_options[column] == "collapse" then
        Tell(" ")
      elseif saved_data.column_options[column] == "shorten" then
        Hyperlink("!!" .. GetPluginID() .. ":beginCurioSort(" .. column .. " collapse)", "<", "Collapse this column", "silver", "black", false)
      else
        Hyperlink("!!" .. GetPluginID() .. ":beginCurioSort(" .. column .. " shorten)", "<", "Shorten this column", "silver", "black", false)
      end
      Tell(" ")
    else
      Tell(s1)
    end
    
    Hyperlink("!!" .. GetPluginID() .. ":beginCurioSort(" .. column .. ")", t, "Sort by this column", "white", "black", false)

    if #s2 > 2 then
      Tell(" ")
      if saved_data.column_options[column] == "collapse" then
        Hyperlink("!!" .. GetPluginID() .. ":beginCurioSort(" .. column .. " shorten)", ">", "Show more of this column", "silver", "black", false)
      elseif saved_data.column_options[column] == "shorten" then
        Hyperlink("!!" .. GetPluginID() .. ":beginCurioSort(" .. column .. " show)", ">", "Show all of this column", "silver", "black", false)
      else
        Tell(" ")
      end
      Tell(s2:sub(1, #s2 - 2) .. "|")
    else
      Tell(s2 .. "|")
    end
  end
end

function displayFooter(total, ignored, expiring, expired)
  local total_width = longest.altar + longest.zone + longest.room + longest.affect + longest.expire + 4

  Tell(".")
  if saved_data.column_options.altar ~= "hide" then
    Tell(string.rep("-", longest.altar))
    Tell(".")
  end
  if saved_data.column_options.zone ~= "hide" then
    Tell(string.rep("-", longest.zone))
    Tell(".")
  end
  if saved_data.column_options.room ~= "hide" then
    Tell(string.rep("-", longest.room))
    Tell(".")
  end
  if saved_data.column_options.affect ~= "hide" then
    Tell(string.rep("-", longest.affect))
    Tell(".")
  end
  if saved_data.column_options.expire ~= "hide" then
    Tell(string.rep("-", longest.expire))
    Note(".")
  end

  local footer_text = {}
  if total > 0 then table.insert(footer_text, total .. " total altars") end
  if ignored > 0 then table.insert(footer_text, ignored .. " ignored") end
  if expiring > 0 then table.insert(footer_text, expiring .. " expiring") end
  if expired > 0 then table.insert(footer_text, expired .. " expired") end

  Tell("|")
  Tell(centerString(table.concat(footer_text, ", "), total_width))
  Note("|")

  Tell(".")
  Tell(string.rep("-", total_width))
  Note(".")
end

function centerString(str, total_length)
  if total_length == nil or total_length <= 0 then total_length = longest end
  local str_len = #str
  if total_length <= str_len then
    return str:sub(1, total_length)
  end

  local padding = total_length - str_len
  local left_padding = math.floor(padding / 2)
  local right_padding = padding - left_padding

  return string.rep(" ", left_padding) .. str .. string.rep(" ", right_padding)
end

function showCommands()
  showCommand("curio sort", "show your curio altars sorted by expiration date")
  showCommand("curio sort filter", "show only your expiring and expired altars")
  showCommand("curio ignore <altar>", "add or remove a specific altar from the sort output")
  showCommand("curio offset <hour>", "manually set the hour(s) offset from system time")
  showCommand("curio sort <column>", "use the provided column to sort, or reverse it")
  showCommand("curio sort <column> <option>", "change how the column is shown")
  Note("   > columns: altar, zone, room, affect, expire")
  Note("   > options: show, shorten, collapse, hide")
  Send("")
end

function showCommand(cmd, desc)
  Tell("* ")
  ColourTell("white", "black", cmd)
  Tell(" - ")
  ColourNote("silver", "black", desc)
end

function CheckForUpdates()
  if can_update then
    update_helper.Update(GetPluginInfo(GetPluginID(), 6):gsub("\\", "/"), "curio_sort.xml")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/consthelper.lua")
    update_helper.Update(GetInfo(56):gsub("\\", "/"), "lua/serializationhelper.lua")
  else
    ColourNote("red", "black", GetPluginName() .. ": UpdateHelper was not found. Make sure updatehelper.lua is in your lua folder.")
  end
end

]]>

</script>

</muclient>
